---
title: 《你不知道的JavaScript》(三卷)
date: 2022-11-14 07:31:58
cover: false
tags:
- 书籍
categories: '书籍'
typora-root-url: 《你不知道的JavaScript》(三卷)
---

[TOC]

> 上卷

# 作用域和闭包

## 作用域是什么

### 编译原理



### 理解作用域



### 作用域嵌套

### 异常



### 小结



## 词法作用域

### 词法阶段



### 欺骗词法



### 小结



## 函数作用域和块级作用域

### 函数中的作用域

### 隐藏内部实现

### 函数作用域

### 块作用域



## 提升

### 先有鸡还是先有蛋

### 编译器再度来袭

### 函数优先

### 小结

## 作用域闭包

### 启示



### 实质问题

### 现在我懂了

### 循环和闭包

### 模块



# this和对象原型

## 关于this

### 为什么要用this

### 误解

### this到底是什么

### 小结



## this全面解析

### 调用位置



### 绑定规则



### 优先级



### 绑定例外



### this词法



### 小结



## 对象

### 语法



### 类型



### 内容



### 遍历



### 小结



## 混合对象“类”

### 类理论



### 类的机制



### 类的继承



### 混入



### 小结



## 原型

### `[[Prototype]]`



### "类"



### （原型）继承



### 对象关联



### 小结



## 行为委托

### 面向委托的设计





### 类与对象



### 更简洁的设计



### 更好的语法



### 内省



### 小结



> 中卷

# 类型和语法



# 异步和性能

> 异步方面，可以先看下《js从基础到进阶》中关于EventLoop的描述



## 异步：现在和将来



## 回调

> 可以先看下《JS设计模式》中对观察者模式和订阅发布模式的描述



## Promise

> 前提：
>
> - 了解回调函数
> - 理解回调函数方式，带来阅读代码的不连续问题
> - 理解回调函数带来的控制反转问题

### 什么是Promise

#### 未来值



#### 完成事件



### 具有then方法的鸭子类型



### Promise信任问题

#### 调用过早



#### 调用过晚



#### 回调未调用



#### 调用次数过少或过多



#### 未能传递参数/环境值



#### 吞掉错误或异常



#### 是可信任的Promise吗



#### 建立信任



### 链式流



#### 术语：决议、完成以及拒绝



### 错误处理



#### 绝望的陷阱



#### 处理未捕获的情况



#### 成功的坑



### Promise模式

#### `Promise.all([ .. ])`





#### `Promise.race([..])`



#### `all([..])`和`race([..])`的变体



#### 并发迭代



### `Promise API`概述

#### `new Promise()`构造器



#### `Promise.resovle()`和`Promise.reject()`



#### `then()`和`catch()`



#### `Promise.all([...])`和`Promise.race([...])`



### `Promise`局限性

#### 顺序处理错误





#### 单一值

##### 分裂值



##### 展开/传递参数



#### 单决议



#### 惯性



#### 无法取消的`Promise`



#### `Promsie`性能



### 小结



# 生成器



## 打破完整运行































