---
title: '数据类型检测和相互转换详解'
date: 2022-8-26 07:15:24
cover: false
tags:
- javascript
categories: 'javascript'
typora-root-url: 数据类型检测和相互转换详解
---



> 课程内容
>
> - `ECMA262`数据类型的详细剖析
>   - 数据类型的标准定义
>   - `Sysmbol`和`BigInt`的实践运用
>   - `typeof`检测的底层机制
> - 数据类型间相互转换的权威解读
>   - `Number/parseInt`底层处理机制
>   - “相等”比较中的类型转换
>   - `JS`中的装箱和拆箱操作
> - 几道互联网大厂的经典面试题



# 灵魂拷问

> 面试题：聊聊`JS`的数据类型检测

-  常见的数据类型检测方法有哪些？
- `typeof`
- 如果想要封装一个类型检测方法，应该怎么做？

# 数据类型有哪些

- 原始值类型（值类型/基本数据类型）

  - `number` 数字

  - `string` 字符串

  - `boolean` 布尔

  - `null` 空对象指针

  - `undefined` 未定义

  - `symbol` 唯一值

    - 目的为了创建唯一值，不能被`new`

      ```js
      let a1 = Symbol('AA')
      let a2 = Symbol('AA')
      console.log(a1 === a2) // false
      ```

    - 常见的3种应用场景：

      - 给对象设置唯一值的属性名

        - 字符串
        - `Symbol`类型
        - `Map`新的数据结构，可以允许属性名是对象

        ```js
        
        let obj = {
            n: 10,
            10: 100,
            true: 200,
            [Symbol('AA')]: 300
        }
        console.log(obj[Symbol('AA')]) // undefined, 两次创建的Symbol不一样
        
        let key = Symbol('BB')
        let obj2 = {
            n: 10,
            10: 100,
            true: 200,
            [key]: 300 
        }
        console.log(obj2[key]) // 300
        
        let obj3 = {
            n: 10,
            10: 100,
            true: 200,
            [Symbol('AA')]: 300,
            [Symbol('AA')]: 600
        }
        
        console.log(obj3) // { '10': 100, n: 10, true: 200, [Symbol(AA)]: 300, [Symbol(AA)]: 600 } 重写call方法时，会使用这种用法
        ```

      - `Symbol`身上的一些方法，如`Symbol.asyncIterator/iterator/hasInstance/toPrimitive/toStringTag...`是某些`JS`底层实现的机制，了解这些机制对我们应用`JS`有很大帮助。

        ![image-20220828124447129](image-20220828124447129.png)

      - `Redux`做公共状态管理的时候，会对派发的行为标识做管理，可以基于`Symbol`类型的值，保证行为的唯一性

  - `bigint` 大数

    - 前端发展过程中，用来弥补`JS`已有的数据类型缺陷

      - `JS`中最大安全数

        ```js
        console.log(Number.MAX_SAFE_INTEGER) // 9007 1992 5474 0991
        ```

      - `JS`中最小安全数

        ```js
        console.log(Number.MIN_SAFE_INTEGER) // -9007 1992 5474 0991
        ```

      - 值超过安全数后，进行运算或者访问时，结果会不准确

        ```js
        console.log(Number.MAX_SAFE_INTEGER + 2) // 9007 1992 5474 0992
        ```

    - 应用场景：客户端如果拿到这样的数，再进行计算，肯定是不行的了

      - 解决方案

        - 1.服务器返回给客户端的大数，按字符串的格式返回

        - 2.客户端将其变为`bigint`类型，然后按照`bigint`进行运算

          ```js
          console.log(BigInt('90071992547409912434234') + BigInt(12345)) // 90071992547409912446579n
          ```

        - 3.最后把运算过的结果变为字符串，再传递给服务器即可

          ```js
          console.log((90071992547409912446579n).toString()) // 90071992547409912446579
          ```

          

- 对象类型（引用数据类型）

  - 标准普通对象：`object`
  - 标准特殊对象：`Array/RegExp/Date/Math/Error...`
  - 非标准特殊对象：`Number/String/Boolean...`
  - 可调用/执行对象（函数）：`function`

# 数据类型检测

平时项目中会涉及数据类型检测

- `typeof`
- `instance of`
- `constructor`
- `Object.prototype.toString.call`



- `Array.isArray()`
- `isNaN`

## `typeof`

- 在浏览器（计算机）底层，基于数据类型的二进制值进行检测

## `instance of`

一开始并不是用来检测数据类型的，而是用来检测当前实例是否属于某个类的



## `constructor`



## `Object.prototype.toString.call([value])`

## 小结



## 拓展阅读













































































































































































































































































