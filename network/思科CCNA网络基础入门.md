[TOC]



教程来源：https://www.bilibili.com/video/BV1Qb411G7bD?p=1

第五集，能看到电脑操作：https://ke.qq.com/course/172514?taid=1017443392856546

## 1.计算机网络

### 1.1.网络是什么

- 端系统

- 中间系统（NA）

将地理位置不同的多台计算机，

通过通信线路连接起来，

在网络操作系统中，网络管理软件及网络通信协议的管理和协调下，

实现资源共享和信息传递的计算机系统。

### 1.2.网络架构

#### 1.2.1.RS(Router Switch)架构

描述的是中间系统的架构

- PC端

- 交换机
  - Cisco-2900
  - 很多接口
  - 交换机组建的网络，是局域网

- 防火墙（硬件）
  - 火绒（软件）
  - 深信服（软件）
- 路由器
  - Cisco-3640
  - 路由器接口没有交换机的多
  - 路由器有开关，而交换机没有
  - 得办宽带，通过路由器把网线连出去

交换机、路由器的最终目的，是实现通信



端系统是会变化的：PC、手机、IP网络电话

中间系统也是会变化的：WIFI网络

### 1.3.网络的类型

路由器和交换机能实现什么样的网络？

- 局域网（LAN）：一组终端设备和由共同的组织管理的用户
  - 所有的用户，都接在一台交换机下，局域网就形成了
  - 局域网游戏、通信
  - 
- 广域网（WAN）：连接分布于不同地理位置的LAN
  - 分布于不同地理位置的局域网
  - 广域网实质上，就是N多不同的局域网，拼接而成
  - 路由器，是可以把一个局域网的数据，发到另外一个局域网的设备
- 局域网、广域网和Internet之间的关系
  - 路由器出口，连接到哪里？
    - 宽带找谁买的？运营商（ISP）
    - ISP物理层面，可以简单理解为一节一节的路由器
    - ISP的某个路由器，再连接到远程的局域网
    - 最终实现本地和远程通信
  - 不同ISP的局域网（电信、联通、移动）
    - Internet就是，不同ISP的局域网，之间的通信

终端与对端

- 在PC上做的任何事情，都有相应的人，要给你提供服务
  - CS模型
- 凭什么找到对应的服务
  - 下一节

## 2.OSI-TCP分层

凭什么找到对应的服务

应用程序有很多，路由器交换机的厂商有很多，电脑品牌都有很多

中间的这些数据，是如何精确的，传到想要的对端上的?



OSI分层模型来解释，源是怎样通过不同的应用程序，通过不同的中间系统，到不同的目的端

### 2.1.OSI分层

- 20世纪70年代后期，ISO创建OSI参考模型，希望**不同供应商的网络**能够相互协同工作
- OSI：开放互联系统（open system interconnection）
- ISO：国际标准化组织（International Organization for Standardization）

#### 2.1.1.为什么要分层

分层的优点：

1.促进标准化工作，允许各个供应商进行开发

2.各层间相互独立，把网络操作分成低复杂性单元

3.灵活性好，某一层变化不会影响到别层，设计者可专心设计和开发模块功能

类比于快递系统

### 2.2.OSI&TCP/IP

| OSI参考模型 |     TCP/IP协议     |
| :---------: | :----------------: |
|   应用层    |       应用层       |
|   表示层    |       应用层       |
|   会话层    |       应用层       |
|   传输层    |       传输层       |
|   网络层    |     网络互联层     |
|   链路层    |     网络接口层     |
|   物理层    | 网络（链路）接口层 |

常用的是TCP/IP

#### 2.2.1.物理层

部署一个网络，先有第一层

- 物理层的主要作用，是产生并检测电压发送，和接收带有数据的电气信号

- 物理层是不提供数据的纠错服务的，但是在物理层上，能对数据的传输速度作一定的控制，并能检测数据的出错率
- 在物理层传输电器信号的载体我们称之为，位流或比特流

物理层部署的就是网线，就是**接线**

物理层里面走的是数字信号，即比特流

物理层设备

- 屏蔽双绞线（STP）
- 非屏蔽双绞线（UTP）
- 集线器
  - 让比特流信号质检，能够相互交通
- 转化器
- 中继器
  - 还原/放大比特流信号的

猫（调制解调器）不是上网设备，是用来转信号的，数模转换，将数字信号转换为模拟信号，才可以通网

除了网线，还有光纤、无线，都属于物理层接线设备

#### 2.2.2.数据链路层

- 数据链路层决定数据通讯的机制，差错检测
- 提供对网络层的服务
- 合成传输的帧数据

主要对应的是网卡上的Mac地址，类比于车牌号

只有设备上，有Mac地址，才能证明该设备是一个网络设备

数据链路层设备

- 交换机
  - 依赖Mac地址来管理、连接所有的硬件设备

- 网桥
- 网卡

**Mac地址**

Mac地址的结构

由48位二进制数组成，通常表示为12个16进制数

前24位是标准组织（IEEE）制定的，后24位是厂家自己制定的节点标识符，例如：00-IC-25-91-65-48

#### 2.2.3.网络层

因为Mac地址都是唯一的，想要找到对方，就没有什么计算方法

范围一旦扩大，难度就增加了

所以，网络的分层，在有了网线，有了接口Mac，承认它是一个网络设备的基础之上，为了能够把数据在全球范围，又快又准的找到对方，就增加了IP的概念

- 为网络设备提供逻辑地址
  - 不再是看得见，摸得着的东西了
  - IP是用逻辑算法编译出来的地址
  - 既然是逻辑算法编译，就可以通过逻辑算法来选路，找一个最快的路径，这就是为什么我们现在上网这么快
  - 这样的地址，叫做因特网地址，也叫做公网IP？？
  - Mac地址对应的网络，叫做以太网，IP地址对应的网络，叫做因特网
- 负责数据从源端发送到目的端
- 负责数据传输的寻址和转发

网络层设备

- 路由器
  - 依靠IP地址进行逻辑选路最优最快的算法， 把数据传递到目的端，这就是IP存在的意义
- 为什么交换机不能上网？
  - 因为交换机不识别IP，而路由器能

一二三层，满足的是中间系统，接下来就是端系统的分层，都是属于逻辑层

#### 2.2.4.传输层

为了端系统上面的应用程序，一旦想要向网络中转发数据，就需要用到传输层为它传输

也就是说，传输层是专门为应用层提供，端到端的服务的

所以，有应用层，才有传输层，如果应用层不存在，传输层也就不存在

先了解下一小节的应用层



传输层到底为应用层，提供了什么样的服务

- 传输层负责建立端到端的连接，负责数据在端到端之间的传输
- 传输层通过端口号区分上层服务
- TCP（传输控制协议）
  - 面向连接
  - 可靠传输
    - 丢包重传
  - 流控及窗口机制
  - 使用TCP的应用
    - Web浏览器、电子邮件
    - 文件传输程序
- UDP（用户数据报协议）
  - 无连接
  - 不可靠传输
  - 尽力而为的传输
  - 使用UDP的应用
    - 域名系统（DNS）、视频流
    - IP语音（VoIP）

#### 2.2.5.应用层

- 应用层的作用主要是为应用软件，提供接口，从而使得**应用程序**能够使用网络服务
- http,ftp,telnet,dns,smtp...
- 常见端口号，类比于110、112公共的电话号码
  - 每一个端口号，都是对应一个应用程序

| 应用程序 | 默认端口号 |
| :------: | :--------: |
|   HTTP   |     80     |
|   FTP    |     21     |
|  Telnet  |     23     |
|   SMTP   |     25     |
|   DNS    |     53     |
|   TFTP   |     69     |
|   SNMP   |    161     |
|   RIP    |    520     |

- 一个应用程序，就对应于一个服务端口
  - 端口号就是区分应用程序的
  - 应用层提供端口号，传输层按照提供的服务端口，去找到对端的服务程序
  - 这是端到端之间的关系

### 2.3.借助OSI模型来理解数据传输过程

核心：**封装&解封装**

pc通过qq产生了数据，这样的数据被称为应用层数据，只有pc才能明白，这是什么东西，而同样能理解应用层数据的，是对端的服务器。

现在数据要向外传输，应用层就提供了端口号（qq的端口是4000，4000就代表了qq这个应用程序的编号）

应用程序一旦产生，传输层就要提供端到端的服务，传输层与应用层，由于分层不同，传输层要传输应用层数据，不可能直接发到对端的应用层，而只能是传到对端的传输层

为了保证传输层能够传递（通信），在发数据之前，传输层协议，会在数据流之前进行打包（类比于寄快递前打包裹），以阐明用的是TCP还是UDP（假设传输层，使用的是UDP为QQ进行服务）

现在在外面，看不到QQ的数据了，能看到的就只是UDP的包而已

现在要向外传，不知道里面是什么了，对端也不好辨别里面的内容，所以把应用层提供的端口号，放在传输层的报头里

此时UDP报头写着4000端口号，就意味着UDP里面的，是QQ

现在传输层掌握的信息是，我要找对端服务端口号是4000的，但是，只掌握这些信息，能够传嘛？

明显是不够的

就要借助传输层的底层，网络层。网络层提供的是IP地址，也就意味着，要利用提供的IP地址，去寻找对端服务所在的IP地址，到底在哪里

同理，要利用IP去传输的话，包就不能这么传了，IP也要对数据进行一层封装，于是又在数据前面盖了一个报头（IP的部分）

同理，现在在外面，看不到UDP报头里的信息了，能看到的就只是IP的包而已，

为了对数据进行辨别，所以在IP里面有一个叫协议号的东西，用来表明，未来拆掉IP，里面放的是什么传输协议，什么内容（UDP在IP里对应的协议号，是17，这些都是定死的）

此时IP报头写着17的协议号，就意味着拆掉IP后，没有惊喜，里面就是UDP

IP还要有什么呢？要有源IP和目的IP

通过源IP和目的IP，按照IP的逻辑寻址，最快的找到服务所在的IP的那一点，就OK了

至此，IP就已经是一个数据包的形态了，能够向外进行转发了，只要PC能够发到路由器，一跳一跳的，就能找到对方

然而这个数据包，最终是要从物理接口发出，IP只是物理接口的逻辑地址，物理接口上还有一个Mac地址

所以我们的硬件接口要对数据包进行最后一层封装，以太网封装

同理，要加上type（类型位），现在在4层报头中，2层叫类型位，3层叫协议号，4层叫端口号，虽然表示的内容不一样，但是本质上类似，都是表示拆掉之后，我封装的那个东西是什么

除此之外，还有什么信息呢？还有源Mac地址和目的Mac地址，现在数据的封装才算完整。

数据包从PC端发出，第一个承接的，是交换机，交换机是一个二层设备，只可以识别Mac地址

交换机按照源Mac和目的Mac，在局域网进行短距离的传输，传递给路由器

路由器是一个三层设备，在看完源Mac和目的Mac没问题之后，还要按照三层IP的报文去分析，从而进行转发，因为路由器是按照源IP和目的IP去转发的

数据对于路由器而言，被二层挡住了，路由器要看到三层封装的数据，必须要解封装，拆掉之后要看到IP的部分，要看目的IP到底是谁，到底要进行怎样的转发

而路由器往外发的时候，又会封装一个新的以太网，继续去发送

最后到了服务器

服务器是一个七层的，以太网、IP、UDP识别完依次拆掉之后，最后看端口号4000提供的服务的，我也有，是QQ的

服务器的应用程序，对数据进行处理之后，再返回过去，重复上述的全部过程

所以，从应用层到物理层，从上到下，是一个加封装的过程，反之

整个数据的传输过程，就是加封装、解封装重复的过程，只不过中间系统的层数没那么多而已

这也就解释了，为什么厂商不同，应用程序不同，最后还能够传递网络精确匹配？

因为中间的这堆设备，包括源、目的两端，在处理数据的时候，都是按照数据包头进行处理的，只要识别包头就可以了，不用管应用层内部传的是什么内容，类比快递，只要识别地址就够了，不用管里面寄的是什么东西



- 封装时一些专有名词

原始的应用层数据，称为payload（负载）

每个协议的小块，称为报头

被传输层UDP封在了里面，单独的，每一层的协议，像UDP报头的那一小块，称为Head，原来的payload称为数据，数据+报头加在一起，称为报文，UDP那一段的报文，称为segment（段）

IP的报头，与UDP和应用层的部分，IP报头是HEAD，UDP和应用层的部分，又变成了数据，IP的整个报头加数据，称为Packet（数据包）

以太网，又把后面所有的东西封装在一起，对于以太网头部来说，IP部分又变成了数据，以太网头部加数据，称为Frame（帧）

都是一个东西，只不过是封装的层数不一样，交换机转发的是帧，路由器转发的以及网络上传输的是数据包，至于分段、负载都是每个应用层的端去处理的



网工玩的主要是网络层，入门的就是第一件事，就是分配一个合理的IP地址

## 3.IP地址及子网掩码划分

### 3.1.十进制VS二进制数

- 十进制数由0到9表示
- 二进制数由一连串的1和0表示

| 十进制 | 二进制 |
| :----: | :----: |
| 0      | 0 |
| 1      | 1 |
| 2      | 10 |
| 3      | 11 |
| 4      | 100 |
| 5      | 101 |
| 6 | 110 |
| 7 | 111 |
| 8 | 1000 |
| 9 | 1001 |
| 10 | 1010 |
| 11 | 1011 |
| 12 | 1100 |
| 13 | 1101 |
| 14 | 1110 |
| 15 | 1111 |
| 16 | 10000 |
| 17 | 10001 |
| 18 | 10010 |
| 19 | 10011 |

IP地址是三个点分，四个小节

每个小节都是8个比特，十进制的每个小节的大小，是取决于二进制每个小节的大小

由于位数的限制，所以每个小节的最大值是八个一，换算成十进制，是255

所以IP地址的范围是0.0.0.0~255.255.255.255，对于学习IP来说，不需要把32位所有的二进制，全换算成十进制，只需要搞清楚每个小节的换算就可以了

下表，表示每个比特，值为一时代表的十进制数

| 128  |  64  |  32  |  16  |  8   |  4   |  2   |  1   |      |      |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  1   |  0   |  0   |  0   |  0   |  0   |  0   |  0   |  =   | 128  |
|  1   |  1   |  0   |  0   |  0   |  0   |  0   |  0   |  =   | 192  |
|  1   |  1   |  1   |  0   |  0   |  0   |  0   |  0   |  =   | 224  |
|  1   |  1   |  1   |  1   |  0   |  0   |  0   |  0   |  =   | 240  |
|  1   |  1   |  1   |  1   |  1   |  0   |  0   |  0   |  =   | 248  |
|  1   |  1   |  1   |  1   |  1   |  1   |  0   |  0   |  =   | 252  |
|  1   |  1   |  1   |  1   |  1   |  1   |  1   |  0   |  =   | 254  |
|  1   |  1   |  1   |  1   |  1   |  1   |  1   |  1   |  =   | 255  |

### 3.2.地址分类

| 分类 | 起始      | 结束            |
| ---- | --------- | --------------- |
| A类  | 1.0.0.1   | 126.255.255.254 |
| B类  | 128.0.0.1 | 191.255.255.254 |
| C类  | 192.0.0.1 | 223.255.255.254 |
| D类  | 224.0.0.1 | 239.255.255.254 |
| E类  | 240.0.0.1 | 255.255.255.254 |

127的地址段，分给了操作系统，作为环回地址了

在pc中，可以从内存中，虚拟出一个ip地址，环回接口就可以理解为这个内存接口

如果能ping通127.0.0.0，证明网卡是好的

127非要分类，算A类

**用途**

![在这里插入图片描述](https://img-blog.csdnimg.cn/0588028a90054060aa22c4e4d7d020ee.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAU2FpYWJsZQ==,size_18,color_FFFFFF,t_70,g_se,x_16)

实际使用的，只有A、B、C三类

每一个不同分类的ip地址，区别在于系统默认的子网掩码，是不一样的

### 3.3.子网掩码

| 分类 | 范围                      | 默认掩码      |       |
| ---- | ------------------------- | ------------- | ----- |
| A类  | 1.0.0.1~126.255.255.254   | 255.0.0.0     | ==/8  |
| B类  | 128.0.0.1~191.255.255.254 | 255.255.0.0   | ==/16 |
| C类  | 192.0.0.1~223.255.255.254 | 255.255.255.0 | ==/24 |

**子网掩码的作用**

将一个ip地址，规划为两个部分

如一个常见的ip地址，192.168.1.1

这是一个C类地址，默认的子网掩码是255.255.255.0

255对应的是1，被1盖住的部分，称之为网络位：192.168.1

没有被盖住的部分，称为主机位：1

子网掩码要求必须是连续的，不存在11111110  11111111这样的



**地址数量**

| 分类 | 可容纳主机数量    |
| ---- | ----------------- |
| A类  | 2^24-2 = 16777214 |
| B类  | 2^16-2 = 65534    |
| C类  | 2^8-2 = 254       |

按照不同的分类，部署不同的网络

**网络地址（Network）**：也可以称作网络号，唯一指定了每个网络。同一个网络地址中，每个计算机都共享相同的网络地址，并用它作为自己的IP地址的一部分，它定义了IP地址所属的网段。

**结点地址（主机地址 Host）**：也可以称作主机地址，是在一个网络中用来标识每台计算机的，它也是唯一的标识符。相对于网络而言，它是用来独立标志指定计算机的。

192.168.1.0这个地址，代表了这个网络下的所有地址，是不能够被分配的，在路由的时候要用到

192.168.1.255这个地址，称为广播地址，你往这个地址发一个信息，这个网络内的所有地址，都可以收到，也不能够被分配给主机

**特殊的IP地址**：0.0.0.0代表所有的网络地址



### 3.4.VLSM

变长子网掩码（Variable-Length Subnet Masks VLSM）的出现是打破传统的以类（class）为标准的地址划分法，是为了缓解IP地址紧缺而产生的

作用：节约IP地址空间

注意：使用VLSM时，所采用的路由协议必须能够支持它，这些路由协议包括RIPv2,OSPF ,EIGRP和BGP（有类/无类）

VLSM划分子网的简单方法：

举例：某公司现有一C类网段192.160.1.0/24，目前有以下几个部分：销售部/59台，技术部/27台，业务部/121台，会计部/10台。需求：将一个C类网段合理分配给如下几个部门，保证地址合理分配

192.168.1.0

255.255.255.0000 0000



255.255.255.1000 0000   2^7 = 128 个主机



划分两个子网：

192.168.1.0  1-126 127

192.168.1.128  129-254 255





255.255.255.1100 0000  2^6 = 64个主机

划分四个子网：

192.168.1.0  1-62  63

192.168.1.64  65-126  127

192.168.1.128  129-190  191

192.168.1.192  193-254  255



.......



255.255.255.1111 1100

4个主机，2个可用，所以有效的子网掩码范围到/30



上面的C类地址的规划



B类地址的子网规划：

1和0在哪个小节发生碰撞，就在哪个小节计算，不要放一起



172.16.0.0/20

255.255.1111 0000.0

这里只看第三段，16个网络，16个主机（有多少个1就有多少个子网，有多少个0就有多少个主机）

172.16.0.0 ~ 172.16.15.255

172.16.16.0 ~ 

172.16.32.0



对于一个C类地址，192.168.1.0/25

255.255.255.    1          000 0000

​    网络位        子网          主机位

所以在规划一个地址的时候，要清楚这个地址，默认它是属于哪一类，弄清楚它的网络位

然后，再把多出来的定义为子网位，

看子网位有多少个1，然后算2的几次方就可以了

最后是主机位

以上是IP地址的规划

回到案例：某公司现有一C类网段192.160.1.0/24，目前有以下几个部分：销售部/59台，技术部/27台，业务部/121台，会计部/10台。需求：将一个C类网段合理分配给如下几个部门，保证地址合理分配

这里先考虑的是主机数量，2^6=64刚好比59大，

意味着子网掩码是255.255.255.1100 0000

我们可以分出4个网络段来：

192.168.1.0

192.168.1.64

192.168.1.128

192.168.1.192

在这里面，随便给销售部分配一个子网掩码就可以了



但是，一般我们规划的时候，规划数量最多的121台

2^7=128刚好比121大，意味着子网掩码是255.255.255.1  000  0000，可以分出2个网络段来：

192.168.1.0

192.158.1.128

随便给业务部分配一个，

业务部    

IP地址：192.168.1.0 ~ 127  

子网掩码：255.255.255.128



第二多的59台，

子网就是刚开始的4个段：

192.168.1.0

192.168.1.64

192.168.1.128

192.168.1.192

这里注意的是，前两个段，第一次划分的时候，已经没了

现在剩下的，只有

192.168.1.128

192.168.1.192

销售部分配是这样的

IP地址：92.168.1.128 ~ 191

子网掩码：255.255.255.192

以此类推。

### 3.5.CIDR

与VLSM相反，是把子网变短

192.168.0.0

255.255.255.0 --> 255.255.0.0

相当于把网络汇总了，在路由中用到

### 3.6.私有IP地址

1.A类地址中：10.0.0.0到10.255.255.255

2.B类地址中：172.16.0.0到172.32.255.255

3.C类地址中：192.168.0.0到192.168.255.255

注：私有IP一般用于公司内部，私有地址可以相同，这会涉及到后面要讲的--NAT

## 4.基础命令集汇总

软件：

- packet tracer
- gns3

### 4.1.以太网技术的线缆标准

T-568A=绿白-绿-橙白-蓝-蓝白-橙-棕白-棕

T-568B=橙白-橙-绿白-蓝-蓝白-绿-棕白-棕

标准网线：不同设备用直通线，即两头都是568A或者都是568B

交叉网线：同等设备用交叉线，即一头为568A，一头为568B

> 因为要做信号对冲，所以反过来

全反线：一般用于配置线缆，两端线序刚好相反

![在这里插入图片描述](https://img-blog.csdnimg.cn/e8162310f25948cd96dc7472464b5e22.png)



在模拟器中，左下角找到connectiosn--Copper Cross-Over，虚线代表交叉线

![在这里插入图片描述](https://img-blog.csdnimg.cn/faef9254501c4f8bb0e9e845ec227110.png)

如果是pc的话，要用笔记本连接console线，一台一台的去配置

点击左边路由器，进入cli界面，一开始界面上输入no，否则就要进行各种的配置

![在这里插入图片描述](https://img-blog.csdnimg.cn/5166330a109c4bd188983f5ea17d46c2.png)

### 4.2.基础命令集汇总

![在这里插入图片描述](https://img-blog.csdnimg.cn/29be968ae72e4aa8991ca2c7d9c71a87.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/2312e4d5c17341bcbc00d968f68eedc1.png)

#### 4.2.1.基础命令集

```
>enable

#configure terminal

// 进入接口才可以配置Ip(快速以太网口)
// f0/0 f0/1 f0/2 表示一个插槽上，有好几个接口
// f0/0 f1/0 表示有好几个插槽
(config)#interface fastEthernet 0/0

//接口模式
//配置IP，IP + 子网掩码
(config-if)#ip address 192.168.1.1 255.255.255.0
// 同步设置不关闭，把接口打开
(config-if)#no shutdown

// 退出命令
// 回到上一级
exit
// 直接回到特权模式
end

// 查询命令
// show 命令
// running-config 保存在ram中，关机就没了
#show running-config
// 不查询所有，只查ip
#show ip interface brief

// 配置主机名，便于辨识
(config)#hostname r1
// 设置进入特权模式的密码
(config)#enable password 111111

// 删除操作
// 一般情况下，当初在哪个模式下，怎么输的，在前面加 no 就可以
// 如果是有自己决定的参数，删除时可以不加
no 

// 类似于 enable password，但是可以避免别人 show run 查询密文密码 
(config)#enable secret 111111

```

#### 4.2.3常见模式

![](https://img-blog.csdnimg.cn/2011fa94c1e34b49b3013afd1489792e.png)

#### 4.2.4.命令语法检查

![在这里插入图片描述](https://img-blog.csdnimg.cn/d11fc32605f74f1288872e68159053d2.png)

#### 4.2.5.快捷键

![在这里插入图片描述](https://img-blog.csdnimg.cn/7d21d8be0ef4416d924e10815f1a808f.png)

#### 4.2.6.工程三招

```
// 关闭域名解析（防止特权模式下，测试时敲错命令查询），如果真敲错了，可以用ctrl+shift+6中断
(config)#no ip dommain lookup
// 测试完之后，一定要再打开
(config)#ip dommain lookup

// 全局模式下，进入控制台
(config)#line console 0
// log当前显示信息同步，实际配置时，各种配置需要等一会才会同步生效的
// 这样可以让，延迟显示的信息，和自己敲的命令，不会混在一起
(config-line)#logging synchronous 
// 关闭会话超时，防止一段时间不操作自动退出
(config-line)#no exec-timeout 
```



## 5.静态路由协议

### 5.1.接线：R1 f0/0  -- R2 f0/0

```

Router>enable 
Router#conf ter
Enter configuration commands, one per line.  End with CNTL/Z.
Router(config)#int f0/0
Router(config-if)#ip add 192.168.1.1 255.255.255.0
Router(config-if)#exit
Router(config)#hostname r1
r1(config-if)#no sh
r1(config-if)#
%LINK-5-CHANGED: Interface FastEthernet0/0, changed state to up
```

链路协议开启

f0/0上的ip协议被开启

```
// 查询路由表
r1#show ip route
或者
r1(config-if)#do show ip route
Codes: C - connected, S - static, I - IGRP, R - RIP, M - mobile, B - BGP
       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area
       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2
       E1 - OSPF external type 1, E2 - OSPF external type 2, E - EGP
       i - IS-IS, L1 - IS-IS level-1, L2 - IS-IS level-2, ia - IS-IS inter area
       * - candidate default, U - per-user static route, o - ODR
       P - periodic downloaded static route

Gateway of last resort is not set

C    192.168.1.0/24 is directly connected, FastEthernet0/0

// C 表示直连

```

R2的f0/0必须要是1.0网络的，

至于R2配置的到底是不是f0/0，得看你接线的时候，接的是哪一个

配置R2 f0/0

```
r2>enable
r2#conf ter
Enter configuration commands, one per line.  End with CNTL/Z.
r2(config)#int f0/0
r2(config-if)#ip add 192.168.1.2 255.255.255.0
// 配置完一定要打开
r2(config-if)#no sh

r2(config-if)#
%LINK-5-CHANGED: Interface FastEthernet0/0, changed state to up

%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/0, changed state to up

// 在全局模式下，想要执行特权模式下的show，可以不用exit，直接加do
r2(config-if)#do ping 192.168.1.1

Type escape sequence to abort.
Sending 5, 100-byte ICMP Echos to 192.168.1.1, timeout is 2 seconds:
.!!!!
Success rate is 80 percent (4/5), round-trip min/avg/max = 0/0/0 ms
// 感叹号表示通了，至于第一个为什么没通，涉及到ARP，下一节讲
```

可以看到，左边的线变绿了，表示线路连通

![在这里插入图片描述](https://img-blog.csdnimg.cn/28b32fe1a7e94c65b047ebbc96da5e01.png)

### 5.2.接线：R2 f0/1  -- R3 f0/0

问：R2 的 f0/1接口，需要配什么样的ip地址呢？可不可以配 1.0 的网络呢

不能，如果你还配1.0的网路，那就是两个局域网，连成了一个更大的局域网了

而路由器是连接两个不同的ip地址段的，所以路由的每个接口，涉及的一定是不同的ip地址段

如果你要连接相同的ip地址段，就没有必要用路由器了

所以，路由器有一个特性：隔离广播域，隔离掉每个地址段

答：只要不是1.0网络，都可以配

配置R2 f0/1

```
r2>en
r2#conf ter
Enter configuration commands, one per line.  End with CNTL/Z.
r2(config)#int f0/1
r2(config-if)#ip add 192.168.2.1 255.255.255.0
r2(config-if)#no sh

r2(config-if)#
%LINK-5-CHANGED: Interface FastEthernet0/1, changed state to up
```

查看R2的路由表

```
r2(config-if)#do show ip route
Codes: C - connected, S - static, I - IGRP, R - RIP, M - mobile, B - BGP
       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area
       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2
       E1 - OSPF external type 1, E2 - OSPF external type 2, E - EGP
       i - IS-IS, L1 - IS-IS level-1, L2 - IS-IS level-2, ia - IS-IS inter area
       * - candidate default, U - per-user static route, o - ODR
       P - periodic downloaded static route

Gateway of last resort is not set

C    192.168.1.0/24 is directly connected, FastEthernet0/0
C    192.168.2.0/24 is directly connected, FastEthernet0/1
```

R2有1.0和2.0两个网络，显示可能会有3~5分钟延迟，可以先去配R3 f0/0，再回来查看R2的路由表

配置R3 f0/0

```
Router>
Router>en
Router#conf ter
Enter configuration commands, one per line.  End with CNTL/Z.
Router(config)#hostname r3
r3(config)#int f0/0
r3(config-if)#ip add 192.168.2.2 255.255.255.0
r3(config-if)#no sh

r3(config-if)#
%LINK-5-CHANGED: Interface FastEthernet0/0, changed state to up

%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/0, changed state to up
```

查看R3的路由表

```
r3(config-if)#do show ip route
Codes: C - connected, S - static, I - IGRP, R - RIP, M - mobile, B - BGP
       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area
       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2
       E1 - OSPF external type 1, E2 - OSPF external type 2, E - EGP
       i - IS-IS, L1 - IS-IS level-1, L2 - IS-IS level-2, ia - IS-IS inter area
       * - candidate default, U - per-user static route, o - ODR
       P - periodic downloaded static route

Gateway of last resort is not set

C    192.168.2.0/24 is directly connected, FastEthernet0/0
```

R3 只有一个直连的2.0网络

### 5.3.连通情况与未连通情况

- 现在的连通情况是

  R1 f0/0 和 R2 f0/0是通的

  R3 f0/0 和 R2 f0/1是通的

- 未连通情况是：

  R1 f0/0 和 R2 f0/1是不通的

  R3 f0/0 和 R2 f0/0是不通的

路由器转发数据的过程：

ping发包遵循的ICMP协议，是一个三层包，没有传输层和应用层，是靠源IP和目的IP进行转发的

我们用R1的1.0网络，去pingR2的2.0网络：

```
r1(config-if)#do ping 192.168.2.1

Type escape sequence to abort.
Sending 5, 100-byte ICMP Echos to 192.168.2.1, timeout is 2 seconds:
.....
Success rate is 0 percent (0/5)
```

ping动作发生时，路由器会根据数据包里面，IP头部的目的IP，去查询自己的路由表，看看有没有到达目的IP的路由

现在ping的是2.1，R1 路由表没有2.0的网络

R1路由表：

```
C    192.168.1.0/24 is directly connected, FastEthernet0/0
```

R1需要2.0的网络，干嘛呢？

去确认出口在哪里

1.0的网络路由表，告诉了路由器是直连，1.0网络从f0/0这个口，向外发包

所以，此时R1没有2.0网络，无法确认数据从哪个接口发出去

所以，没有路由的情况下，发不出去数据包

这三台设备，要想实现互相通信，都要有彼此的路由条目信息

要在R1上面，用静态路由的办法，给R1写上2.0的路由

```
r1(config)#ip route 192.168.2.0 255.255.255.0
```

最后还要加上下一跳，也是一个ip地址，这里表示的R1到R3，经过R2时的入接口，应该是R2的f0/0，也就是192.168.1.2

```
r1(config)#ip route 192.168.2.0 255.255.255.0 192.168.1.2
```

再看一下路由表：

```
C    192.168.1.0/24 is directly connected, FastEthernet0/0
S    192.168.2.0/24 [1/0] via 192.168.1.2
```

`S`表示静态

但是，下面这条路由，没有出接口，意味着没有源IP

下一跳这种设置，会造成递归查询，

路由器会查询，是不是有1.2的路由表，有的，

最后数据从f0/0的接口出去

我们在R1 ping一下2.1的网络：

```
r1(config)#do ping 192.168.2.1

Type escape sequence to abort.
Sending 5, 100-byte ICMP Echos to 192.168.2.1, timeout is 2 seconds:
!!!!!
Success rate is 100 percent (5/5), round-trip min/avg/max = 0/0/1 ms

```

一去一回才叫通，此时R2是有1.0的路由表，所以能返回给R1

而如你去Ping R3的话，数据包可以到R3，但是R3不能返回来，因为R3没有配1.0的路由

相应的，R3设置一下1.0的路由：

```
r3(config)#ip route 192.168.1.0 255.255.255.0 192.168.2.1
r3(config)#do show ip route
S    192.168.1.0/24 [1/0] via 192.168.2.1
C    192.168.2.0/24 is directly connected, FastEthernet0/0
```

此时，R1是可以ping通2.2的

```
r1(config)#do ping 192.168.2.2

Type escape sequence to abort.
Sending 5, 100-byte ICMP Echos to 192.168.2.2, timeout is 2 seconds:
.!!!!
Success rate is 80 percent (4/5), round-trip min/avg/max = 0/0/0 ms

```

如下设置，匹配的是单独的主机：

```
r1(config)#ip route 192.168.2.1 255.255.255.255
```

静态路由的第二种写法，先删除之前的配置：

```
r1(config)#no ip route 192.168.2.0 255.255.255.0 192.168.1.2
```

配置的时候，不写下一跳，直接设置出接口：

```
r1(config)#ip route 192.168.2.0 255.255.255.0 f0/0
r1(config)#do show ip route
C    192.168.1.0/24 is directly connected, FastEthernet0/0
S    192.168.2.0/24 is directly connected, FastEthernet0/0
```

这两种写法，有什么区别呢，还得涉及到下一节ARP的知识

第三种写法：

```
r1(config)#ip route 192.168.2.0 255.255.255.0 f0/0 192.168.1.2
```

这种写法，写上出接口的同时，又写上了下一跳，在GNS3里可以，但在packet tracer提示无效输入



静态路由缺点就是繁琐，优点就是省开销

不适用大型的网络，但应用还是很多



第四种写法，表示全网络，也不设置掩码：

```
r1(config)#ip route 0.0.0.0 0.0.0.0 f0/0 192.168.1.2
```

该设置表示，我要通过192.168.1.2，去往所有的网络（你能去哪，我就去哪）

这种写法，只适用于末梢网络（只有一条路可以出去的网络），只适合在最左边的设置

![image-20211024201124447](image-20211024201124447.png)

如果不再末梢设置，而中间设置：

```
0.0.0.0/0 via 192.168.1.2
              192.168.2.2
              192.168.3.2
```

在中间的路由表里，会出现三个并列的下一跳，这叫负载均衡

一旦匹配走第二个路由的时候，1.2/2.2/3.2都会发一个包

有可能你找的目的地址，只在1.2后面，而2.2、3.2都没通，会导致网络不稳定

并且，路由表有一个相对掩码最长匹配规则：

优先级：

```
12.1.1.1/32
12.1.1.0/24
12.0.0.0/8
0.0.0.0/0
```

路由表是在没有匹配的情况下，才会匹配0.0.0.0/0

应用场景：公司网关的路由器，通过运营商到所有网络

## 6.ARP协议

上一节留的坑：

1.为什么ping的时候，第一下会是一个点（表示不通）？

2.为什么设置静态路由的地方，把下一跳设置，换成出接口，会和ARP有关系？

### 6.1.什么是ARP协议

ARP：Address Resolution Protocol，地址解析协议

ARP的作用：将已知的IP地址解析为Mac地址

![在这里插入图片描述](https://img-blog.csdnimg.cn/69d5652c01804d18a5dd853100fb5933.png)

ARP在请求的时候，是广播请求，单播响应

一开始的时候，是没有Mac地址，所以一开始是不会通的

广播的IP是255.255.255.255，那么广播的Mac地址是什么呢？是FF-FF-FF-FF...，所有都是F



这里使用GNS3软件

新建文件，重新配置下：

R1:

```
outer>
Router>enable
Router#config ter
Enter configuration commands, one per line.  End with CNTL/Z.
Router(config)#int f0/0
Router(config-if)#ip add 192.168.1.1 255.255.255.0
Router(config-if)#no sh
%LINK-5-CHANGED: Interface FastEthernet0/0, changed state to up
```

R2：

```
Router(config-if)#ip add 192.168.1.2 255.255.255.0
```

R1向R2发包，ping 192.168.1.2，返回一个点，4个叹号 

使用GNS3自带的抓包工具，可以看到ARP包：

![在这里插入图片描述](https://img-blog.csdnimg.cn/f0f1b0b911fc471aaf4ab35a65f477fa.png)

在f0/0口，抓了8个ICMP包和2个ARP包（2层）

点开ARP包：

![在这里插入图片描述](https://img-blog.csdnimg.cn/fbe90de04079497b9a33f08396ac3063.png)

可以看到它目的Mac，全是ff

其他的一些信息：

![在这里插入图片描述](https://img-blog.csdnimg.cn/0f7c9317776c4dd6b7d2bbc663600125.png)

目的Mac是我们想要求的，所以是空的

以上是请求的ARP包。

接下来看1.2的ARP包是如何回复的：

![在这里插入图片描述](https://img-blog.csdnimg.cn/eeba9834b9f946bebb2bb5e18a12322e.png)

回复中，由于是单播回复，目的Mac就是1.1的Mac

那1.2在回复的时候，是如何得知1.1的Mac呢？

因为1.1一开始发的ARP是广播请求，当1.2发现1.1中，请求的目标是自己的时候，它会把1.1发的ARP包中的源Mac和源IP给学习（记录）下来

而网段内的其他路由器，发现请求的不是自己，就直接忽略了

所以，是1.2先有的1.1的Mac和IP，1.2也就可以给1.1单播回复一个ARP的响应

类比：在50人教室大喊，谁是张三？张三听到了，回复：我是张三！

下面是1.2单播回复的ARP响应：

![在这里插入图片描述](https://img-blog.csdnimg.cn/0be871ceb8ec4c69a96eca456a62408d.png)

所以，第一次ping会有一个点，因为那个时候在发ARP

特权模式下，查看ARP映射表：

```
show arp
```

以上是同一个ip地址段进行广播，

如果请求的目的ip，不在同一网段下，该怎么办呢？

事实上ARP请求的，并不是对方的Mac，而是下一跳的Mac：

![在这里插入图片描述](https://img-blog.csdnimg.cn/846c7ad13b044e31879ceaec6f9555e8.png)

这里我们ping 2.1和2.2，ping通后再查看arp映射表：

![在这里插入图片描述](https://img-blog.csdnimg.cn/a8795f3487e84e60a127324ed15a0131.png)

发现只有1.2的

PC也是，它也是只解析网关的

事实上，以太网的头部，每经过一个网段（路由器），都会重写源Mac

另外一个问题：代理ARP

当我们的路由没有下一跳的时候，就会触发代理ARP

更改一下路由表：

![在这里插入图片描述](https://img-blog.csdnimg.cn/c7581d8642654356be6b1e96c9bfc3dc.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/4e99e70a460048158926d73b5481759d.png)

查看路由表，只有出接口，没有下一跳

此时，我们再都ping一下，之后查看arp映射表：

![在这里插入图片描述](https://img-blog.csdnimg.cn/0b314dff94db4b6fbe331482609910f1.png)

这种情况，就是代理arp（思科路由器都是默认开启的）

关闭掉代理arp后，再ping是不通的

![在这里插入图片描述](https://img-blog.csdnimg.cn/227b2ac2c2354b4a95a9c696a03b0d53.png)

代理arp可以会有多个，原则是后到优先

所以只写出接口的话，会依赖代理ARP，同时会写大量的arp映射，并且存在次优选路的问题

### 6.2ARP攻击（欺骗）

由于是广播，所以如果假冒是你请求的ip地址，再去访问你一次，就算你之前访问过了真的ip地址，由于后到优先的原则，你就会把Mac重新记录

而下一次你再访问的时候，就不是通过网关访问Internet，而是直接把数据发到了攻击者的电脑上

虽然arp是一个二层，实际信息并不会泄露太严重，但一个直观的感受，就是你的网断了

有一种arp病毒，会仿造各种ip地址，局域网中不定期就会出现ip冲突，网就上不去了

解决办法：网关绑定Mac

![在这里插入图片描述](https://img-blog.csdnimg.cn/ea37fbd6b8f34850aab932c9ced2eaeb.png)

所以IPV6中，取消了arp机制

## 7.RIP协议
