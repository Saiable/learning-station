---
title: '状态机'
date: 2023-03-06 09:03:02
cover: false
tags:
- 认知
categories:: 认知
typora-root-url: 状态机
---

# 什么是状态机

## 基本介绍

[能不能通俗的讲解下什么是状态机？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/375631543/answer/2485598947)

![image-20221130100855202](image-20221130100855202.png)

状态机是一种编程思路。一种对对自然界某种事物(或数据)**状态变化的抽象**。

让你的程序开发维护，思路更加清晰方便。

- 它规定了一个实例(某种抽象)，某一时刻只能有一种状态(属性)。一般用字符串表示。

- 规定了只能通过实例的方法，即执行某个动作(函数)，之后才可以改变状态(属性)。

就这两个规定。



再说有限状态机。和状态变更回调。

- 有限状态机，指上诉的状态机，总状态数种类是有限个。

  且规定变化到某种状态，需要验证当前状态是都合理。实现的话，实例化时候需要接收允许从某状态，变化到哪些状态。然后写一个验证，里面就一行 if 判断是否允许。(例如订单，代码层面，不允许从已付款变成未付款，允许从未付款变成已付款，直接改数据库的不算)

- 状态变更回调，指状态变更动作之前和之后执行的函数。

  状态变更动作可能是异步完成，有时候需要知道开始和结束。例如调试时候。



http 请求就是一个典型的有限状态机。状态有 open pending ending error等 ，stateChange ，success 等就是它的状态变更回调。且如果当前是 error ，不能从 error 变成 pending 了。



只要你满足了这些特征。就是状态机。

怎么实现是写法上不同，甚至实例化也不需要只用 new 。如果是自己实现，不用刻意照搬他人代码。

不过，几乎所有语言，都有别人写好的有限状态机的实现库，因为本身也没用多少难度，只要知道语法基础，就能写出来。希望能帮到你。





✔ 状态: 特定时间点的某个对象信息

✔ 转换: 状态之间的转换过程

✔状态机: 多个状态和状态之间的转换组成状态机

✔通常用来描述对象与时间的关系。



▲什么是状态机

状态机是有限状态自动机的简称。有限状态机（英语：finite-state machine，缩写：FSM）又称有限状态自动机（英语：finite-state automaton，缩写：FSA），简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学计算模型。

> 关于有限的解释：也就是被描述的事物的状态的数量是有限的，例如开关的状态只有“开”和“关”两个;灯的状态只有“亮”和“灭”等等。

▲特点

一个状态机可以具有有限个特定的状态，它通常根据输入，从一个状态转移到另一个状态，不过也可能存在瞬时状态，而一旦任务完成，状态机就会立刻离开瞬时状态。每个状态根据不同的前置条件，会从当前状态流转至下一个状态。

▲作用

使用状态机来表达状态的流转，会使语义会更加清晰，会增强代码的可读性和可维护性。

▲适用场景

面对复杂的状态流转(一般是超过三个及以上的状态流转)，那么还是比较建议用状态机来实现的。

![image-20221130101111166](image-20221130101111166.png)

## 视频介绍

[业务新解 | 如何解决当下如此高复杂度的业务场景 | 状态机 | XState_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1PL411y7vF/)

## 好处

目前来说，无论是 to c 业务,还是 to b 业务，对于前端开发者的要求越来越高，各种绚丽的视觉效果，复杂的业务逻辑层出不穷。针对于业务逻辑而言，贯穿后端业务和前端交互都有一个关键点 —— 状态转换。

当然了，这种代码实现本身并不复杂，真正的难点在于如何快速的进行代码的修改。

在实际开发项目的过程中，ETC 原则，即 Easier To Change，易于变更是非常重要的。为什么解耦很好？ 为什么单一职责很有用？ 为什么好的命名很重要？因为这些设计原则让你的代码更容易发生变更。ETC 甚至可以说是其他原则的基石，可以说，我们现在所作的一切都是为了更容易变更！！特别是针对于初创公司，更是如此。

例如：项目初期，当前的网页有一个模态框，可以进行编辑，模态框上有两个按钮，保存与取消。这里就涉及到模态框的显隐状态以及权限管理。随着时间的推移，需求和业务发生了改变。当前列表无法展示该项目的所有内容，在模态框中我们不但需要编辑数据，同时需要展示数据。这时候我们还需要管理按钮之间的联动。仅仅这些就较为复杂，更不用说涉及多个业务实体以及多角色之间的细微控制。

重新审视自身代码，虽然之前我们做了大量努力利用各种设计原则，但是想要快速而安全的修改散落到各个函数中的状态修改，还是非常浪费心神的，而且还很容易出现“漏网之鱼”。

这时候，我们不仅仅需要依靠自身经验写好代码，同时也需要一些工具的辅助。

更多：[利用 XState(有限状态机) 编写易于变更的代码](https://juejin.cn/post/6885370060362219528#comment)

# 关于状态机的技术选型

[关于状态机的技术选型，最后一个真心好！ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/583410988)

今天跟大家分享一个关于“状态机”的话题。状态属性在我们的现实生活中无处不在。

比如电商场景会有一系列的订单状态(待支付、待发货、已发货、超时、关闭）；员工提交请假申请会有申请状态（已申请、审核中、审核成功、审核拒绝、结束）；差旅报销单会有单据审核状态（已提交、审核中、审核成功、退回、打款中、打款成功、打款失败、结束）等等。

上述场景有一个共同问题：根据不同触发条件执行不同处理动作最后落地不同的状态。示例代码如下:

```
Integer status=0;
    if(condition1){
        status=1;
    }else if(condition2){
        status=2;
    }else if(condition3){
        status=3;
    }else if(condition4){
        status=4;
    }
```

那我们最容易能想到的自然是if-else方案。那if-else方案会有什么问题呢？

主要有以下几点：

- 复杂的业务流程，if.else代码几乎无法维护
- 随着业务的发展，业务过程也需要变更及扩展，但if.else代码段已经无法支持
- 没有可读性，变更风险特别大，可能会牵一发而动全身，线上事故层出不穷
- 其他业务逻辑可能也会跟if-else代码块耦合在一起，带来更多的问题

![image-20221130100827168](image-20221130100827168.png)

状态机的出现就是用来解决上述问题的。在复杂多状态流转情况下，通过状态机的引入，我们希望相关代码可读性、扩展性能比if-else方案更好！



## 各个状态机方案

▲枚举状态机

Java中的枚举是一个定义了一系列常量的特殊类(**隐式继承自class java.lang.Enum**)。枚举类型因为自身的线程安全性保障和高可读性特性，是**简单状态机**的首选。





▲状态模式实现的状态机

是什么

状态模式是编程领域特有的名词，是 23 种设计模式之一，属于行为模式的一种。

它允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。

作用状态模式的设计意图主要是为了解决两个主要问题：

1. 当一个对象的内部状态改变时，它应该改变它的行为。
2. 应独立定义特定于状态的行为。也就是说，添加新状态不应影响现有状态的行为



▲开源实现

# 前端状态机

[关于 (zhangfisher.github.io)](https://zhangfisher.github.io/flexstate/#/readme)

[前端状态机：XState 首个中文文档上线了_王乐平的博客-CSDN博客_前端状态机](https://blog.csdn.net/lecepin/article/details/121901602)

**目前开源的有限状态机实现中比较知名的有：**

- `xstate`：堪称状态机航空母舰,功能太强大了，也太复杂了，学习成本非常高。
- `Javascript State Machine`：功能较弱，在实际试用过程中发现在进行异步切换时存在问题。
- `jssm`：特点是引入自己的DSL语法来描述状态机，使用起来比较别扭。

## State Machines in JavaScript with XState 

full video: https://www.bilibili.com/video/BV1Bb4y177EH

captions: [State Machines in JavaScript with XState | Frontend Masters | Frontend Masters](https://frontendmasters.com/courses/xstate-v2/)

### Introduction

> The "Introduction" Lesson is part of the full, State Machines in JavaScript with XState, v2 course featured in this preview video. Here's what you'd learn in this lesson:
> David Khourshid introduces the course by providing a brief overview of the course material and walks through the course repository. A demonstration of the final state of the project is also provided in this segment.

Hello, everyone, my name is David Khourshid, and I'm really excited to be doing another workshop on state machines with XState in JavaScript. And we're gonna be discussing a lot more than version one of the workshop. So if you've taken version one, and you've taken the React's versions of the workshop, then we're going to be building on top of that.

Still working in vanilla JavaScript, but we're going to be going over a lot of things today. We're gonna be going over software modeling, when to use state machines and when to use state charts, all the fundamental parts of state machines and state charts. They're going to be useful in your everyday applications.

And we're also gonna be talking a lot about the actor model and how you could use actors to represent the different parts of your application that are communicating with each other. So like I said, my name is David Khourshid, I work at Stately, which is a company that I founded.

And we're creating a lot of tools for visualizing application logic, whether it's with state machines, or state charts, or other types of diagrams. So a lot of what we do today is actually going to be represented in the tools that we're building at Stately. I'm also on Twitter @DavidKPiano, so please feel free to follow me, reach out to me, DM me, whatever you want.

So before we get started, I wanna talk about how this workshop is going to be structured. So you should have received the link to the GitHub repo, it's at https//github.com/davidkpiano/frontend-masters-xstate-v. The previous workshop is Frontend Masters XState Workshop. So if you do wanna go back and review that, then a lot of the material will be similar, but there's also a lot of new things in this workshop.

Now, this assumes that you have Node installed because this is a JavaScript application. And we're going to be using Vite, it's a newer tool just for bundling applications and making them run, and I found that very useful. This application is a vanilla JavaScript app, we're not using any frameworks.

And this is important because we want to keep things simple. And also we want you to learn skills that you could apply to any framework that you're using with XState, whether it's React, Vue, Svelte, Angular, any of those frameworks, or even no framework at all, if you're applying XState in different contexts.

So of course, make sure that you have Node installed and NPM installed as well. To get started, you are going to run npm install, or if you're using Yarn, you could run yarn install as well, or just yarn. And then you're going to run npm run dev. This is going to start the web server at localhost port .

And so when you do that, and I'll do that real quick right now. So you just go to, all right, we're in there, so you're going to run yarn or npm install. I've already done that, so I'm just gonna run yarn dev. And so this is going to run the site at localhost .

So if we go to localhost , You're going to see the main page here. Now, let me show you in the repo where this lives. If you git clone the repo and bring it down to your local system, you're going to see in VS Code, you're gonna see a whole bunch of folders.

Each of these folders contains files for the exercises that we're going to be doing, but the main file that you see over here lives right here in the main repo. So this is the index.html page, and you can use this as a scratch pad. And so I really encourage you to do so.

We're going to be using this a lot for just going over the various concepts in XState and also playing around with some code before we jump into the exercises. So just to test that everything's working, if you console.log a nice Hello world!, then you should be able to see it right in the console over there.

And that's how you know that things are working. Vite is also really good at doing fast refresh, so keep that in mind. When you make changes to the files, you don't have to manually reload, you could just see it live in the actual window. Now, what we're actually building today is a real world app.

We're building a media player. And so if you go to the last exercise, which is  Testing, you're going to see this media player in action. Now, this is just one of your typical media players. It doesn't actually connect to media because we're not trying to play audio over here.

But it's a good starting point for if you do want to create a media player that does play media, either through the audio, the Web Audio API, or some other mechanism, then you could use this exact same app logic that we create in XState to do so. This app has a number of different functions.

You could like or unlike a song, dislike it, you could play or pause, of course, you could skip forward, and you can mute and unmute the microphone. This is also an app that's meant to be incomplete, which means it is really what you make of it. Because while we do have certain functionality that we're going to be building here, the functionality that you decide to add is something that can be added on after the fact.

So if you wanted to add advanced audio controls like changing the microphone volume, or if you want to do things like go back and go forward, or maybe display a playlist. This app is meant for you to really experiment and see all the different things that you could add, and also realize how easy it is to add once you have the app logic modelled as a state machine.

So really, this is something that is for you to play around with and is not meant to be % complete. Rather, each of the exercises are meant to teach different parts of XState, and state machines, and state charts, and parts of the actor model. And like I said, it's up to you to build on top of those things.

```bash
git clone https://github.com/davidkpiano/frontend-masters-xstate-v2.git

npm i

npm run dev

```

### Software Modeling

#### Software Modeling

##### What is software modeling?

We're gonna be starting with our first lesson which is on software modeling. Instead of jumping right into state machines and statecharts, I really want to get down to the why of state machines and statecharts. And why you would actually want to use these types of things when the way we've been coding really didn't touch on state machines or statecharts for however many years we've been coding.

But why it's important today and should have been important the entire time we've been developers. So the first question is what is software modeling? Software modeling in short is the art of planning ahead, at least in my own words. Really, if you look up what software modeling is, you see that it talks a lot about abstractions.

And that's really what software modeling is about is creating a layer of abstraction that is one degree separated from the code. So the code is the implementation layer and the model is the abstraction layer. Now, there are many ways to model software, one of the most popular ways and useful in my opinion to do so, is by using diagrams.

So, you might have started planning software in the past by just grabbing a whiteboard or maybe a pencil and paper and drawing user flows or flowcharts or diagrams like entity relationship diagrams. And just trying to understand what your code is supposed to do and accomplish at a higher level.

And so this essentially is what software modeling is. It's creating these abstract models that we could code against. However, something that I see way too often in software development is jumping straight into the code. So we'll look at something like a user interface of something we're supposed to implement and one of our first reactions says, okay, let's start coding the user interface.

And then we start adding functionality on top of that user interface by putting a lot of logic and event handlers. And if something needs to be different, then we'll add an if statements. And this is what quickly creates spaghetti code. So this is something that we really wants to avoid just by planning ahead.

Now, one of the problems or I'd like to call it a friction points with diagrams is that diagrams aren't always up to date with the code. We might draw a really nice architecture diagram or a flowchart describing our code. But once we starts to code, and once new requirements come in, it becomes double efforts to both update the diagram and also update the code.

So that's what state machines and statecharts are for. And we're gonna talk about that in a little bit. But it allows you to do both the software modeling upfront and the actual implementation at the same time, and do it in a way that you could change the model and the implementation and they could stay completely in sync.

And so this allows you to add new features, change features, and really understand your software as a whole in one step. Instead of doing it in multiple steps of creating a diagram, then code into the diagram, or even skipping the diagram altogether, which definitely not a good thing.

##### Event-driven architecture

So state machines and statecharts are part of what's called events-driven-architecture. And so event driven architecture is about the fact that you have events as a primitive, anything that can happen to whatever app or software that you're programming is an event. So something that a user does, whether they click something, or swipe something, or type something in, all of those are events.

And by events I mean things that happen which is the literal definition of an event. So when the user clicks a button, that button clicked events is an event that can be fed into this model that we created and so that model can decide what should happen next based on that events.

Now keep in mind that events aren't just something that originates from the user, but events can also be something that originates from the system or other systems that are interacting with your software itself. For example, if we start fetching a promise, then the user action of clicking a button or pressing answer on a phone to start fetching that promise is an events.

But also the promise resolving or rejecting, those are also events and they don't come from the user. So it's important to keep in mind that events encompass anything that can happen in your application, and not just things from the user. So how do we specify behavior in an application?

##### Specify behavior(given-when-then,etc.)

This is where things like given-when-then and test-driven developments come into play. And these are really loose specifications for how we talk about how our application is supposed to behave. Now, let's actually talk about the media player for a minute because I want us to start creating a specification on how it's supposed to work.

And you could see that specification if you go into modeling and this readme. We have a loose text description of what is supposed to happen in the app at each step. Now I actually really like given-when-then. And that's because when we represent a specification in this given-when-then structure, we already have all of the building blocks we need to make a really solid model of our application.

So, for example, we say we have here a song when loaded will start playing by default. So, we could say that given, and I will bump this up. Let's just use large over here. Given a song is not loaded yet. When a song is loaded, then the song should start playing.

![image-20230310174420377](image-20230310174420377.png)

So now we have everything here that represents just the different building blocks of our application, or at least one small part of our application. So, this given over here is a state, is a precondition, but it could also be represented as a state in our application. So we had this idea of a song not being loaded yet.

And then this one represents an event. So when a song is loaded, so now we know that that loading, or that loaded part is an events that can happen in the application. Then the song should start playing. So now we have a different states. If the states aren't changing, then this then part is going to be exactly the same as the given.

But user specifications usually specify that the state of the application does change. So we have a bunch of these user stories. The user could also play or pause the song and we could translate that to, for example, given the song is playing, when the user presses pause, then the song should be paused.

So now we have our playing states, our paused state, and the events of clicking the pause button to pause the song. So, that's why specifying behavior is so useful and this is why we typically do this using user stories because it gives us all of the building blocks of specifying our application.

>  So is modeling making a list of all possible events that can occur in an app?

Yes, exactly. Like I was talking about before, typically when we start coding an app, we start coding with the user interface and just start shoving events in there. So now that we're thinking in an event-first architecture, event-first really describes that there's a bunch of events happening, and our application is going to react to those events.

But it can be really tempting to put all of the logic inside of event handlers for this. And this typically isn't really the best way to go especially as the app scales up in features. For example, you might be putting fetch logic inside of a form submit handler.

Or you might be having like defensive conditions and if statements inside of a click handler that determines what should happen when this button is clicked. For example, you might say if the form is loading and the submit button is clicked again, then we might have an if statement, like if, if is loading, then do nothing, otherwise start fetching the data.

And this makes the behavior implicit. It makes the behavior such that we're describing the application in terms of when this event happens, do this, but also keep in mind these conditions. And so now instead of thinking in terms of like the entire state of the application. Or thinking in terms of okay, let's have an event just do something and if that's not doing the exact thing we want it to, add more if statements in there so that we get to do the behavior we want.

And so that's why I encourage you to take a step back into a state-first approach instead. And so I'm going to demonstrate what we mean by this. And this is also going to get into state machines and statecharts as well. So first, when we look at this, this specification, we have a state-first approach already over here.

We say when the song is loaded, then the song should start playing. But we have this precondition over here too, given a song is not loaded yet. Now, we can make another user story that says, for example, given a song is playing, when the pause button is pressed, then the song should be paused.

![image-20230310174917038](image-20230310174917038.png)

All right, so this specification allows us to prevent any unintentional behavior of, for example, if the pause button is pressed when the song is already paused, if you have a pause button visible. Or if the play button is visible while the song is already playing and the user happens to press it again.

Some unintended behavior might happen if the exact same button is pressed more than once and we're attaching logic to the event handler instead of considering a state-first approach. And so that's why this given part of the given-when-then statements are so important. And so like I was saying, this gets into what state machines and statecharts really are.

#### State Machine in Vanilla JavaScript

##### Event-first vs. state-first

So I'm going to go into the scratch pad over here, and we're going to start by creating a very simple state machine. That's doesn't need any libraries, it's just, we're going to be using just a switch statement and we're going to be modeling a simple prompt. So I'm just going to have over here, function, let's just call this transition.

And so this is going to describe transitioning the states or describing what the next state should be given this current state in events. And we're going to be describing like I said, a simple fetch flow, so we have state and event. And so, typically we would start by saying or by having a switch on the events dot type.

So this is assuming that the events looks like type FETCH or it could have other payload like that in the states. It doesn't matter exactly what it looks like but let's assume that the state looks like states, we have data, null, error, null, things like that. All right, so when we start switching on the event type, we might do something like case FETCH.

And then we could say console dot log, starting to fetch data, break and defaults break. Okay, so I'm just gonna say, window dot transition equals transition. And we're going to attach this directly to the window, so we could start playing around with it. And I encourage you to do the same thing if you're playing around with things in the scratchpad as well.

```js
// main.js
import './style.css';
import { createMachine } from 'xstate';

// state: {data: null, error: null, ...}
// event: {type: 'FETCH}
function transition(state, event) {
    switch(event.type) {
        case 'FETCH':
            console.log('Starting to fetch data');
            break;
        default:
            break;
    } 
}

window.transition = transition;
```

So we could transition again the state doesn't matter right now, but let's say that we have a type of FETCH. Okay, so now it says starting to fetch data, but the immediate issue here is that. The user or even something else in the system can send that fetch events multiple times and it begin to start fetching data repetitively.

![image-20230311090345991](image-20230311090345991.png)

And so we want to avoid unwanted states and unwanted actions like that. So that's why, let's just assume that we have a status over here. So let's say that we have status of idle and so we have starting to fetch data, break. It's something that we would typically do, well actually first let's change the state.

So we're going to return status loading and we're going to see if that's and just as a follow through, we're going to return the state.

```js
import './style.css';
// import { createMachine } from 'xstate';

// state: {status: idle}
// event: {type: 'FETCH}
function transition(state, event) {
    switch(event.type) {
        case 'FETCH':
            console.log('Starting to fetch data');
            return {status: 'loading'};
            break;
        default:
            break;
    } 
    return state;
}

window.transition = transition;
```

 Okay, so now, if we transition status, let's say that we're idle and we send the FETCH events. 

![image-20230311091447132](image-20230311091447132.png)

Okay, so now it says status loading, but what happens if the status is already loading?

![image-20230311091858235](image-20230311091858235.png)

It's going to fetch data again and so this is something that you might immediately see if you start clicking a button multiple times. So your first inclination would be probably to have a little bit of defensive logic to solve this problem. So we would say, if state dot status is not loading, Then we're going to start to fetch data.

```js
import './style.css';
// import { createMachine } from 'xstate';

// state: {status: idle}
// event: {type: 'FETCH}
function transition(state, event) {
    switch (event.type) {
        case 'FETCH':
            if (state.status !== 'loading') {
                console.log('Starting to fetch data');
                return { status: 'loading' };
            }
            break;
        default:
            break;
    }
    return state;
}

window.transition = transition;
```

So now again, if the status is loading and we sent fetch, nothing happens. 

![image-20230311092234980](image-20230311092234980.png)

And so this is the first step to starting to think in terms of states first. So instead of switching on the events type first, what we really want to do is switch some finite state.

So we could use the status in this example and say switch state dot status, and then say case idle. And now we could do our same fetch data over here and so case loading. We could have maybe some other behavior, break and then defaults, break. And then, now what you could do in here and this might look a little bit ugly.

But you could switch on the events dot type if you have multiple events. Or if you're only handling a couple of events per state, what I'd like to do is just put it in an if statement. So I say, if event dot type is fetch, then we're going to start loading the data.

And then we're going to return that status, otherwise, we're just going to return the state. 

```js
import './style.css';
// import { createMachine } from 'xstate';

// state: {status: idle}
// event: {type: 'FETCH}
function transition(state, event) {
    switch (state.status) {
        case 'idle':
            if (event.type === 'FETCH') {
                console.log('Starting to fetch data');
                return { status: 'loading' };
            }
            return state;
        case 'loading':
            // other behavior
            break;
        default:
            break;
    }
    return state;
}

window.transition = transition;
```

And so now, we're going to see that if we have idle over here. It's going to start to fetch data and it's going to return our next date of loading. And so now, when we load it again, like I showed you over here, it's not going to do anything.

![image-20230311093036154](image-20230311093036154.png)

So keep in mind the difference between doing this and taking a state first approach and taking an events first approach. With the state first approach, we don't need to have defensive logic, again this could just be a switch statements. And we don't need to cover up any impossible transitions or states that might arise by doing things events first.

And so the big reason for this is the way we define finite states. Finite states in state machines and state charts, what these represents are behaviors. And so, a behavior is how the application is going to react based on an events. The example I'd like to give is, as humans we're either asleep or awake and those are two different behaviors.

So we could call those states, I'm either in the asleep state or the awake state. And the reason that I would distinguish between those two states is because. I'm going to react differently to events when I'm asleep rather than when I'm awake. And so that should be a good guide for thinking about like how to separate the different reactions to events in your application.

So for example with this fetch logic or separating the idle behavior from the loading behavior. In idle, when the events fetch is sent, then we should start fetching data. In the loading behavior, when the fetch event is sent, nothing should happen. So, that's a good way to distinguish what the different behaviors are.

So, one more thing before I get to the exercise. We could also represent this state first approach, which is actually a finite state machine. We could represent this as an object instead and again, we're not going to be using any libraries. I'm just going to be using an object as a lookup table, so I'm going to call this const machine and I'm going to give it an initial state.

So remember, I'm just using this as a pure lookup table rather than something. That we inject into a library, which we're gonna be doing in the next lesson. So let's say I give the initial state of idle and so now I have a bunch of states, so I have idle and I have loading.

So inside this object, I could specify that on the FETCH events, we should go to the loading states. And we'll just keep it simple for now and keep it like this. By the way, the reason that I'm not just putting fetched directly on the object. Is because we might want to, or in the future, we're going to want to add entry and exit actions and other things.

So this object doesn't just represent transitions, but it could represent other things as well.

```js
const machine = {
    initial: 'idle',
    states: {
        'idle': {
            on: {
                FETCH: 'loading'
            }
        },
        'loading': {}
    }
}

```

 All right, so how do we use this machine to actually work the same way as this transition machine over here. I'm gonna call this transition, and let's give it a states and an event.

So, now instead of creating this big switch statements, we could just look it up on the object. And we could say const nextStates equals the machine dot states. And we're going to be grabbing the, let's just grab the state over here. And remember we're putting it on state dot status, the finite state and then on which might or might not exist and the events dot type.

Now, if this doesn't give us a state, like if it's an event that we don't handle. Then we're just going to return the current state and then we could return status, next status, just like that. So window dot transition equals transition and let's test it out. So I'm also going to be exporting or sharing the machine as well, so window dot machine equals machine.

```js
const machine = {
    initial: 'idle',
    states: {
        'idle': {
            on: {
                FETCH: 'loading'
            }
        },
        'loading': {}
    }
}

function transition2(state, event) {
    const nextStatus = machine.states[state.status].on?.[event.type]??state.status;
    return {
        status: nextStatus
    }
}
window.machine = machine;
window.transition2 = transition2;
```

And so if I console dot log the machine, we're going to see that we have our machine over here. And then transition, now we could build up this initial states with status machine dot initial. Because we have it over here in a nice convenient property, and then we're going to send the events.

Again we are going to be sending a FETCH event and so what happens is, it takes us to the loading state. So this is going to work exactly the same way as our switch statements. And it's going to default to staying at the same state if there are no transitions to find for that events.

![image-20230311095635037](image-20230311095635037.png)

So whichever way you decide to write it without a library, whether you're using an object or a switch statements, it's up to you. The question was, is the transition function a reducer? Yes, the transition function is essentially a reducer. So if you're used to Redux or Vue X or NGR X or any of those other libraries that make use of these reducers, then it's pretty much the exact same thing.

Some of the differences though, are that while it does return the next date in response to a state in an event. It could also contain other things too which we're going to be seeing in the X state. And it sort of has this specific structure where this state is going to have some sort of field that represents the finite states of the machine.

And of course it could represent other things as well but conceptually you can think of it as a reducer. So again, going over the building blocks of what a finite state machine is. Now that we seen it in code, let's take a look at it visually. So we have the idle state and that was our initial state.

So, we also have a symbol that represents that this is an initial state, now we also have loading. And so you could see these states are represented by boxes. So now if we want to describe how the idle state moves to the loading states. In state machine notation we would just draw an arrow like this and then we would add the events that causes the transition.

So, in this case, we have a fetch event. So now the graphical representation of this logic is exactly the same as we're expressing it in code. Whether it's using the object or using the the switch statements. And so to follow this, you would first look for the initial state in this case it's idle.

And then depending on what events the machine receives, you would follow the arrow. So let's say we're in idle and the fetch event happened. So we're going to follow this arrow from idle to loading because that's where the fetch transition takes us. So now if we get a fetch event in the loading states then nothing is going to happen.

And the reason nothing is going to happen is because there's no outgoing transitions from the loading state. And so this is exactly what the finite state machine really helps with, is preventing impossible states and transitions. If instead we had this arrow just floating randomly and going to the loading state.

Then there are the chance that we could have unintended transitions. But because this is a well defined visual formalism, we know that it's impossible. For a fetch events to do anything when we're in the loading states, just looking at the graph we could see nothing should happen.

![image-20230311100326667](image-20230311100326667.png)

#### State Modeling Exercise

We're going to be jumping into the first exercise. And so, if you go to `localhost, port 3000, /00-modeling/`, you could also access this by clicking the link over here. You're going to see a media player, and this doesn't exactly need to be hooked up just yet. It just serves as a visual guide for now.

> http://localhost:3000/00-modeling/

![image-20230311101033866](image-20230311101033866.png)

What we're gonna be mainly doing is working in the console itself. And so, for this exercise, what I want you to do is, you're gonna see a main.js file. We're going to be creating a simple state machine that represents the loading, play, and pause functionality of our media player.

![image-20230311101254435](image-20230311101254435.png)

And so, let's first create the state machine visually over here. So instead of loading, or sorry, instead of idle, our initial state is going to be loading. And this represents loading the song, we're going to have a loaded event. And so, according to the specification, when the song is loaded, we're gonna start playing it.

![image-20230311104244532](image-20230311104244532.png)

So the state machine goes to the playing state. Now, we could go back and forth between the playing and paused states using events. So we could go from playing to paused when we pause it. And we could go from paused to playing, When the play event happens. So basically, I want you to represent this state machine in code without using any libraries.

And yeah, so you could use either a switch statement or an object. And just like we did by attaching the transition function to the window, play around with it, look in the console. Make sure that all of the transitions are actually working. And then if you want to, find a way to localize that state, so you have this object that you could just send events to.

If you don't get that far, then that's okay, we're gonna be doing it together, cuz that's gonna be an important concepts later on.

#### State Modeling Solution

Let's go over how we would represent this state machine using either a switch statement or an object in code. So just like we did for the simple promise example, we're gonna create a transition function over here and we're gonna have a state and an event. And remember too that this state is going to look something like status 'idle' or status 'loading'.

But just to keep with the way that we're doing things in XState, I'd like to have it just as a value. And so I consider this the value of the finite state in the machine. So remember, instead of switching on the event, we're gonna be switching on that finite state.

So switch and then we're gonna say state.value. And so now we have three different states that we're going to be considering. We have the loading state, loading, playing, and paused. So case 'loading', case 'playing', and case 'paused'. Default break. Now, talking about impossible states really real quick, these are really the only possible states that we should have.

So if you really want to, you could throw an error to make yourself feel better and say this should be impossible. But, yeah, using XState or other libraries, it prevents this too, because it ensures that only these possible states happen in your application. Okay, so now, we're going to just return the state, just to make sure.

So in the loading state, we see that only one event can happen. We could have a loaded event and so we should go into the playing state when that loaded event happens. Instead of using a switch statement, cuz it's a little bit too verbose, we're just going to have an if statement, if event.type === 'LOADED', then we're gonna return the state where the value is playing.

And so we're gonna be doing that with the other ones as well. So if the event type is pause, then we're going to go to the paused state. If the event is play in the paused state, we're going to be going back to the playing state. And so this is our entire switch statement over here representing all of the events, states, and transitions, the three main building blocks for building this finite state machine.

But we also do need an initialState too. So const initialState=, and we're just gonna have value, this is going to be loading. In fact, we could do something that I believe Redux does, where if we don't provide the state or just have this explicitly undefined, just say that this is going to be the initialState.

So now, let's attach this to the window, window.transition=transition, and let's play around with it. So we're gonna go back to the media player over here. 

```js
import '../style.css';

// Create a state machine transition function either using:
// - a switch statement (or nested switch statements)
// - or an object (transition lookup table)

// Also, come up with a simple way to "interpret" it, and
// make it an object that you can `.send(...)` events to.
const initialState = {value: 'loading'};

// {value: loading}
function transition(state = initialState, event) {
    switch(state.value) {
        case 'loading':
            if(event.type === 'LOADED') {
                return {
                    ...state,
                    value: 'playing'
                }
            }
            break;
        case 'playing':
            if(event.type === 'PAUSE') {
                return {
                    ...state,
                    value: 'paused'
                }
            }
            break;
        case 'paused':
            if(event.type === 'PLAY') {
                return {
                    ...state,
                    value: 'playing'
                }
            }
            break;
        default:
            break;
    }
    return state;
}

window.transition = transition;
```

And let's first try the initialState and say type 'PLAY'. Now notice I'm intentionally doing the PLAY event to show you that it should not be handled in the loading state because we're still loading the song.

![image-20230311110936992](image-20230311110936992.png)

So you see that the value is still loading just like we expect. But now if I have loaded, now it goes to playing, again just as we expect. And so if I take this and put this over here, and now that we're in the playing state, let's say play happens again, of course, it's still going to be playing.

![image-20230311111134062](image-20230311111134062.png)

And if I have the PAUSE event, it's going to be paused. And so that's how you could do it using a switch statement. But there is another way in that by using the objects notation as well, which I find a little bit simpler and it comes with some other benefits as well.

So I'm going to be making a machine over here, providing the initialState of loading and again, we have three states. We have loading, playing, and paused. So in the loading state, on the loaded events, we go to playing. In the playing state, on the PAUSE event, we go to paused.

And in the paused state, on the PLAY event, we go to playing. And now we could take that same function that we wrote in our scratchpad for just looking things up on this machine, and I'm just gonna copy it here from the final.js. Just gonna copy this. And I'm going to call this machineTransition.

And I'm gonna be using the same technique that we used before and just give this an initialState of value machine.initial. So now it becomes configurable, and we're going to be looking up a couple things. First, we're going to be looking up that state object based on the value.

So for example, if the value is loading, we're grabbing this entire object, and then we're going to be looking up the OnProperty and seeing if there are any transitions. Remember, it might not be defined, so we're gonna put this optional accessor over here. And then we're going to look up if there is a transition on that event.

Now, if any of this is undefined, which is shown over here, if we don't have an XState value, we're going to stay in the currentState. This is how state machines work. If events are not handled in the states that we specify, or that we're currently in, then it stays in the same state.

So just consider that a feature of state machines. So window.machineTransition=machineTransition. 

```js
const machine =   {
    initial: 'loading',
    states: {
        loading: {
            on: {
                LOADED: 'playing'
            }
        },
        playing: {
            on: {
                PAUSE: 'paused'
            }
        },
        paused: {
          on: {
              PLAY: 'playing'
          }
        },
    },
}


function machineTransition(state = {
    value: machine.initial
}, event) {

    const nextStateValue = machine.states[state.value].on?.[event.type] ?? state.value;
    if (!nextStateValue) {
        return state;
    }
    return {
        ...state,
        value: nextStateValue
    }
}
window.machine = machine;
window.machineTransition = machineTransition;
```

And so, this is going to behave exactly the same way as before. So, let's say we have transition, let's call this machineTransition instead. And playerMachineObject, aha, that's because I'm into this machine. There we go. So now we go to playing, just as expected.

And again if we copy this over, we have machineTransition and we have a type of PAUSE, then this is going to go to the paused state. And same thing if we're in the paused state and the PLAY event happens, now we're going to be going to the playing state itself.

![image-20230313071955226](image-20230313071955226.png)

Now, you could get creative with this, this is just a pure function. And pure functions, as awesome as they are especially if you're in love with functional programming. Not having side effects or way to persist states doesn't really make your application that useful. So thankfully we could use this pure function in a way that we could persist the currentState.

And like I said, you could get really creative with this, I'm just going to have a really simple implementation here. So I'm just gonna say let currentState and that's just going to be our initialState of value and machine.initial. And then I'm going to say const, we're gonna call this a service.

And so this service is going to allow us to send events to it. So we could send event. And so we're going to say the currentState should be the result of the currentState and the event that was passed in. And we'll also consol.log, the currentState, just to make sure it does exactly what we expect it to.

So window.service=service. And again, this is a very simple implementation, put this in class, have fun with it, make it subscribable, do whatever you want. But the main point is that now it's something that's live. We're persisting the currentState just in this local variable over here, actually it's a global variable.

And we're also imperatively sending events to the service. So, let's try it out. 

```js
// ...
let currentState = {value: machine.initail};

const service = {
    send: (event) => {
        currentState = machineTransition(currentState, event);
        console.log(currentState)
    }
}
window.service = service;
```

Service.send, so again we're in the initialState right now. So if I send type of loaded, we're gonna get playing. And so again because my state is persisted, if I do PLAY, it's gonna stay on play.

If I do PAUSE, now it's going to be paused. So I could send a gibberish event, and because that event is not handled, it's going to stay in exactly the same state.

![image-20230313072910877](image-20230313072910877.png)

 And so that is a solution to the exercise. Now, also, two things I wanna mention. First of all, if you do wanna go to the solution of the exercise and see it, and I do encourage you to do so if you get stuck, you could always take a look at the final.js file.

And in the actual application HTML, you could uncomment the main.final.js just to make sure that you see the final result. And you could make sure that what you're doing matches up with that final result.

#### State Machines Q&A

One question was, can we say that creating state machines like this is the JavaScript implementation of the good old state design pattern? And so the short answer is yes. The state pattern, if you remember your gang of four design patterns, the state pattern is very similar to a finite state machine.

So in the state pattern if you don't know, a state pattern defines an object that can change its behavior. And so for example, in this application, if we were to represent this as a class, we might have a loading behavior, which is going to be a separate function that describes this is what should happen when I'm loading.

But we're also giving it the ability to change behaviors as well. One good way that you could do this in your app and sort of get closer to that state design pattern is by separating this in a function. So let's say we have this case, let's go over here.

```js
const initialState = { value: 'loading' };

function loadingBehavior = (state, event) => {
    if (event.type === 'LOADED') {
        return {
            ...state,
            value: 'playing'
        }
    };
    return state;
}
// {value: loading}
function transition(state = initialState, event) {
    switch (state.value) {
        case 'loading':
            return loadingBehavior(state, event)
            break;
        case 'playing':
            if (event.type === 'PAUSE') {
                return {
                    ...state,
                    value: 'paused'
                }
            }
            break;
        case 'paused':
            if (event.type === 'PLAY') {
                return {
                    ...state,
                    value: 'playing'
                }
            }
            break;
        default:
            break;
    }
    return state;
}
```

So we have this, if event type is loaded, return the playing state. Otherwise, we just want to return the normal state. And so we could have something like function loading behavior in which we know that if we're in this loading behavior, we're going to have the state value as loading.

And so instead of having to switch on the state, we could just pop this function in. And so we could just cut this, put there, otherwise return the state. And so now over here we could just return loadingBehavior(state, event). So like I said, this gets closer to that state design pattern.

The only difference between this state's design pattern and using a finite state machine is that the state design pattern says the machine, or sorry, the class or object, or whatever you wanna call it, can change its behavior at will. With finite state machines, the only way a behavior can change is due to an event.

And I promise you that's a lot more flexible than it sounds. But it's a good constraint to keep in mind, that you shouldn't be arbitrarily changing behavior, but instead make it due to events. So yea, if you want to refactor this as a separate behavior function, then that's definitely one way to do it.

Does XState allow you to import state machines written in SCXML as XState compatible state machines and export them to, or as SCXML state machines for state machine related tools in libraries? So yeah, that's jumping ahead a little bit. But by SCXML, this is a a specification by the WC.

And it's a state machine notation that is represented, as you probably guessed, in XML. And so this standard, if you read it all in, it's a pretty big read, it is going to feel very close to XState, and that's on purpose. XState implements SCXML and the algorithms. And one of the long-term goals of XState is to be compatible with SCXML in general.

Currently, we do import SCXML internally for a lot of testing, but there aren't public-facing features that allow you to do this easily. But it is definitely possible. So the takeaway from this question is, if you really want to understand what XState is about more in-depth, I really recommend you read the W specification for state chart XML.

You're going to find a lot of things in common with XState and this SCXML notation and see inspiration for a lot of XState's API. The question was, is there a reason to name the events in all caps, or as I like to call it screaming case? The short answer is no, you don't need to do it.

I like doing it just because it's a visual differentiator between states and events. I know something is an event because it's something that's screaming at me. So I could just quickly scan the page and see, that's an event because it's all in uppercase. But there is no reason that you have to do this.

And even myself, I'm finding myself writing lowercase events, like pause, more frequently in my applications. I think the uppercase events name was just something that was started by libraries and Redux, and it became sort of an unofficial convention. If you don't wanna use uppercase, you don't have to.

It's not a restriction in XStates or pretty much anything. There's nothing that's checking that all of your state names are uppercase. However, I will say that for future versions of XState, what you should do is like, if you have events that can really be described within a group of events, so let's say that we have audio paused.

I really recommend that you separate it with a dot. And that's the one convention that's actually going to be really useful. Because in the future, and this is XState version , not XState version , you're going to be able to specify wildcard events. And so this basically handles any event that starts with his audio dot.

And the delimiter is the dot, so this is also specified in SCXML. So that convention I would recommend, the uppercase convention, you can have your own preference on that. There was a comments that we do have a Stately Discord. And for all questions related to state machines, state charts, the actor model, events-driven architecture, software modeling, and also the tools that we release, it's at discord.gg/xstate, open invitation.

I highly recommend that you join this Discord because we are extremely responsive in there and wanna help everyone with all their problems. And there's also so many good ideas and sources of inspiration in the Discord. So if you have any questions or you just wanna chat, feel free to join the Stately Discord, again, at discord.gg/xstate.

The question online was, what about naming the actual states over here? How do we determine what these states should be named?. And so for the states, I have two general guidelines. First, you should name it based on what is happening. And you should also name it based on what the behavior should be.

So as long as you choose any of those, or ideally a combination of both, you should be safe. So for example, in this state we're asking, what's happening? Well, the song is loading. And now we're asking, what's happening over here? The song is playing. And we're asking, what's happening here?

The song is paused. If we were to model something else, like, for example let's say that we're modeling drag and drop, but we're locking to the x-axis or y-axis so you can't move it freely. You could only move it on one of the axes. Then we might have something like, I call it x-axis lock.

And so now, this isn't exactly describing what's happening, it's describing a behavior instead. So this x-axis lock is a state that says any event that happens here, we have to lock any positional changes to the x-axis. So again, this is a demonstration of what's happening or what the behavior should be.

And so that's how you should describe your states. Can a state receive multiple events at the same time? How does the state transition to the next state? And so with state machines and state charts, the idea is that you always receive events one at a time. So for example, let's say that we spammed this machine in the loading state with five instances of loaded, all being sent at the same time, for whatever reason.

Let's say that one of our services is just behaving badly and has some race conditions or something. And we just get multiple events at the same time. So what should happen is those events should be queued up. So we have a queue of events and we pop from the queue each time and we say, okay, let's handle these events one at a time.

So in the loading state, we're only going to handle one event, which is loaded, we transition. And once we're on this state, this all happens immediately, by the way, once we're on that state, then the next loaded event will do nothing. Because we're in the playing state and the loaded transition does not exist on that state.

So in summary, events are handled one at a time, always.

[State Chart XML (SCXML): State Machine Notation for Control Abstraction (w3.org)](https://www.w3.org/TR/scxml/)

### XState

#### Getting Set Up with XState

In the first exercise, we learned how to model this simple state machine using either a switch statement or by using an object. And so now we're going to be taking this to the next level. And specifically focusing on this object, and using this to actually implement a state machine using the XState library.

And so if you go to [xstate.js.org/docs](https://xstate.js.org/docs/), this is the XState library. And the installation and quick start are all on the homepage over here. So you could npm install xstate, and then you create a machine using createMachine. And you interpret the machine, which makes a live version of that machine, which persists state.

And is something like that object we talked about in the first lesson, where you could send events to it. And so when you create a machine, the object syntax that we put inside of here is going to look exactly the same, or at least pretty close, to what we did in the first lesson.

Now the quickest way to get up and running with XState is actually by using the Visualizer. So if you go to [stately.ai/viz](https://stately.ai/viz), you're gonna be greeted by this homepage, where you can see an example or just start coding right away, which we're going to do. And so if I create a machine, I'm actually going to copy this entire object, and I'm gonna put it inside of createMachine over here.

Let's see, const.machine = createMachine. And so when I press Cmd + Enter, or if I click Visualize over here, now you're going to see the state machine visualized in the visualizer. And so it's going to look pretty much like the diagram that we just drew over here. So we have a loading, playing, paused.

And notice we call this AUDIO.PAUSED, it could be paused. And so we could actually navigate through this machine, and show how each event is going to affect the machine's states. So this is a really useful tool, where you could just copy and paste your machines, whether you have it in JavaScript or TypeScript.

```js
import { createMachine } from 'xstate';

const machine = createMachine(
  {
      initial: 'loading',
      states: {
          loading: {
              on: {
                  LOADED: 'playing'
              }
          },
          playing: {
              on: {
                  PAUSE: 'paused'
              }
          },
          paused: {
            on: {
                PLAY: 'playing'
            }
          },
      },

  }
)
```

![image-20230313103008758](image-20230313103008758.png)

And I definitely encourage you to try it out. So, again, if you wanna get started with XState, you would do npm install xstate. And we're are going to be using the createMachine and interpret functions from XState. And so, yeah, just gonna show you how that works real quick.

We're gonna be jumping into exercise number one, just to show you how all of this works. And actually, exercise one is all ready done, so yeah. But if you wanna do it yourself, then please feel free. What should really happen over here is like this should be empty, so yeah.

Okay, so for this exercise, what you're supposed to do is create a machine using XState that matches the state machine that you created in the previous exercise. So just to give you a quick intro on that, I'm gonna jump into the scratchpad over here. And let's clear some stuff out.

All right, so we're going to import a couple things from Xstate, gonna import createMachine and also the interpret function. For now we're just gonna be using createMachine. And so we're gonna be creating a machine using createMachine, saying that a lot. And this machine, the object inside actually doesn't need to take anything.

This is a perfectly valid state machine, even though it's completely empty. So if we console.log the machine.initialState, you're going to discover what exactly is in that state objects that we have. 

```js
// /root/main.js
import './style.css';
import {createMachine} from 'xstate';

const machine = createMachine({

})
console.log(machine.initialState)
```

![image-20230313104220352](image-20230313104220352.png)

So the initial state is created by, let's have initial state of loading, so states, loading. All right, so our initial state is going to have a few important things.

```js
import './style.css';

import {createMachine} from 'xstate';

const machine = createMachine({
    initial: 'loading',
    states: {
        loading: {},
    }
})
console.log(machine.initialState)
```

![image-20230313104831806](image-20230313104831806.png)

First of all is the value, just like we talked about, this value over here of loading. And so this represents the finite state of the machine. There's also going to be an event over here, and that represents the events that caused the transition to this state. In this case it's just an xstate.init event, which is an internal event.

And there's also going to be context, which we're gonna be taking care of in a future lesson. But for now this value is the important part. And yeah, so when we have this machine inside createMachine, we actually have the transition function built into this machine. So we could say const nextState = machine.transition.

And so just like we did before, we could specify undefined as the first argument, and we could give it an event. So let's say that we have two states, loading and loaded. So we say on LOADED 'loaded', that's actually pretty redundant. Let's call it SUCCESS just for the sake of this example.

And so we're gonna send type 'SUCCESS'. And we're going to console.log the nextState. 

```js
import './style.css';

import {createMachine} from 'xstate';

const machine = createMachine({
    initial: 'loading',
    states: {
        loading: {
            on: {
                SUCCESS: 'loaded'
            }
        },
        loaded: {}
    }
});
console.log(machine.initialState);
const nextState = machine.transition(undefined, {
    type: 'SUCCESS'
})

console.log(nextState);
```

All right, so now we see that we have a state with value of loading. And when we send that event, now we have a state with value of loaded. So we see the event in the state object, and we see the value of loaded also within that state object.

Now this state object has a couple of other features as well. So one feature that's going to be useful in our application is matches. So if I say console.log(nextState.matches, and we say loaded, this should be true. And so this gives us an easy way to match and make sure that we're in the expected finite state.

So we have true over here. If we have something else, then it's going to be false. So you can use nextState.matches. Just like we did before in the first lesson, we created this sort of object that lets us send events to the machine and also we have a way to persist the state.

There is a built in way to do that in XState as well, and that's by using the interpret function. And so instead of this, we're gonna be creating what's called a service. And again, this is just convention. But this service is going to take that machine that we created, and we have to call start in order to start the service, and say, I'm ready to accept events.

```js
import './style.css';

import {createMachine, interpret} from 'xstate';

const machine = createMachine({
    initial: 'loading',
    states: {
        loading: {
            on: {
                SUCCESS: 'loaded'
            }
        },
        loaded: {}
    }
});

const service = interpret(machine).start();

service.subscribe(state => {
    console.log(state.value)
})

window.service = service;

```

![image-20230313110433514](image-20230313110433514.png)

Now, we could listen to events on the service by calling service.subscribe. And we are going to console.log the state.value. And we're also going to expose the service on the window, so window.service = service = service. All right, so right now the service immediately told us that we're in the loading state.

So if I send type 'SUCCESS', we called it, now it's gonna tell us that we're in the loaded state, just as we expected. So now we see that everything is working and it's all good. So interpreting the machine to create these services is really useful. And you could use this essentially as an event emitter in your application.

And it becomes something that you could send events to, subscribe to. And those two things alone are really powerful, and it's what's going to drive the entire media player application.

#### State Transitions Exercise

Getting back to the first exercise. What I want you to do is if you see anything in the player machine, delete it and start over. I want you to recreate that machine and just get a feel for adding initial states, so initial states and adding all the states in the state object and also adding the transitions in each of those states.

And so you'll also notice that this is connected to the application. So if we go to  states transitions, these buttons, at least a couple of them the play and pause buttons should work. So, ideally, that's what should happen. We already have the code that hooks that up.

So, yeah.

#### State Transitions Solution

And so this is really useful for debugging or just getting a glance at what state is my application currently in as it's running. We also talked about adding the states and transitions into the machine in a very similar way like we did with the previous exercise of having that objects notation.

So, if we go in here. And we remember that our state machine is supposed to look like this. Where we have a loading, playing, paused state and the loaded, play and pause events. Then hopefully you're getting more used to how to actually add these states and transitions into XState.

You want an initial state at first, so that's going to be our loading state and then we want to specify all of the states that we have in our state machine which is loading, playing and paused. Now to specify a transition inside the loading state, we put it inside the on object which stands for on this event, we go to this state.

So on the loaded state, the way that we specify this XState, the full way is by giving it an object with a target of playing. And so what this is going to do is it's going to say if we're in the loading state and the loaded event happens, go to this next target state which is playing.

Now a shorthand for this is if you have no other actions or things to specify in the object you could just put the key of that state inside as the value instead of the full object. Both ways work both ways are the same. I do recommend you use the object especially if you're going to add actions and conditions, and things like that that we're gonna talk about in the future.

So in the playing state, on pause, we go to the paused state. And in the paused state, on play- We go to the playing state. Now below you see that we already have the machine being interpreted and we also have the step tools true thing. And I'll show you what that does in a minute.

But this starts the service so that it could start receiving events. What we also did, and just for the sake of time, it's already done for you. We have a bunch of elements that we could access. And so, we're adding event listeners to each one of them. And so, this is going to be an important pattern using whatever framework that you plan on using with XState, is that the only thing that should really happen inside events listeners is **sending an event**.

And so this alone simplifies the implementation of the logic in your application and it also allows you to centralize that logic. So now, when we click a button for instance, all that's doing is being translated to a play events and same thing over here with the pause button, when we click it, that's being translated to a pause event.

And so we're also subscribing to the state because we do want things to happen on the screen. So, we want the loading button to be hidden if the state doesn't match loading. We want the play button to be hidden. And so now instead of using matches we could do something else.

Since this play button is based on an event and not the states, we could do it if we can't play. So the state machine does make this obvious where if we're in the playing states then we can't play because that transition is not defined. And so the state.can method allows you to do this pretty easily.

And say if sending this event is not gonna cause a transition in the state machine, then this is going to return false. Otherwise, if it will cause a transition, it's going to return true. So it is really useful and you could use either dot matches or state.can to control the UI.

```js
// @ts-check
import '../style.css';
import { createMachine, assign, interpret, send } from 'xstate';
import elements from '../utils/elements';

import { inspect } from '@xstate/inspect';

// inspect({
//   iframe: false,
//   url: 'https://stately.ai/viz?inspect',
// });

const playerMachine = createMachine({
  initial: 'loading',
  states: {
    loading: {
      on: {
        // LOADED: 'playing'
        LOADED: {
          target: 'playing'
        }
      }
    },
    playing: {
      on: {
        PAUSE: {
          target: 'paused'
        }
      }
    },
    paused: {
      on: {
        PLAY: {
          target: 'playing'
        }
      }
    }
  }
});

const service = interpret(playerMachine, { devTools: true }).start();

elements.elPlayButton.addEventListener('click', () => {
  service.send({ type: 'PLAY' });
});
elements.elPauseButton.addEventListener('click', () => {
  service.send({ type: 'PAUSE' });
});

service.subscribe((state) => {
  console.log(state);
  elements.elLoadingButton.hidden = !state.matches('loading');
  elements.elPlayButton.hidden = !state.can({ type: 'PLAY' });
  elements.elPauseButton.hidden = !state.can({ type: 'PAUSE' });
});

service.send({ type: 'LOADED' });

```

![image-20230313161044356](image-20230313161044356.png)

So congratulations. And when we go into the actual application- We see that this pause play, pause play it works. And so, again when you're testing machines or you just want to debug them you could attach the service to the window- And you could send events that way. So, for example, now we can see the loading state and that's because I commented out this loaded event.

And so if we send the play, nothing's gonna happen. We're still gonna be in the loading state. And that's because we haven't loaded the data yet. So, if we instead send loaded now that changes to the plays states, and I know it confused me before in the past but showing the pause button means it's in the played state because it shows like, okay, you could pause it because it's playing.

So you could click pause, and now it's in the play state, pause state, play, etc. So if your app in this file looks like this and it behaves like this, then it's working. So congratulations. And so this is really useful for debugging or just getting a glance at what state is my application currently in as it's running.

And so this is really useful for debugging or just getting a glance at what state is my application currently in as it's running. So you could import inspect from XState inspect and then give it a couple of options. By default it's gonna try to find an iframe and this option might be changing in the future or this default might be changing.

And we also wanna open it up in `stately.ai/viz?inspect`. And so what this is gonna do is it's going to visualize our machine as it is running in the app. And so this is what we call inspecting the state machine. So right now we see that it's in the loading state.

And so this is really useful for debugging or just getting a glance at what state is my application currently in as it's running. [COUGH] So we can press pause to pause it. And now we see it's in the paused state, but one cool feature about this inspector is that it goes both directions.

You could also click play over here and cause the machine to be playing. So it's bi directional, it's going to work both ways. And so this is really useful for debugging or just getting a glance at what state is my application currently in as it's running.

```js
import { inspect } from '@xstate/inspect';

inspect({
  iframe: false,
  url: 'https://stately.ai/viz?inspect',
});
```

![image-20230313161939312](image-20230313161939312.png)

### Actions

#### Actions

All right. Now let's talk about actions. This was also a question that was brought up like how do we express side effects inside the state machine as well. In state machine and state chart terminology in action is a side effect. It is something that is performed as the result of an event.

So there's three different types of actions that we could specify in those our entry, exit and transition actions. So, one important thing to realize is that actions don't happen randomly, they **happen always due to an events**. So for example, if we're in the loading when we entered the states, and I could just add this over here.

So I'm gonna make this different color, we could say entry load data actually let me make that a little bit smaller if I can [INAUDIBLE]. There we go, so what this is saying is that when we enter this date we want to start loading data and this is a side effects that happens, this side effects might eventually come back and say okay here's your data it's loaded.

And then we go into the playing states. So again, we could represent entry and exit actions here too. So we could say, play audio over here because playing the audio is a side effect. We have to tell something external that the audio file actually needs to start playing and when we're not in this playing states we want to pause the audio.

So this just make sure that the behavior of not only the way that **the machine can change its behavior based on events. But also on what side effects are executed, the behavior of that is specified through these actions**. Now, there are also transition actions and these are actually the actions that I would recommend you start with.

So a transition action in state machine terminology is specified with do. So it's not gonna look like this in x states. But when you're looking at state machine diagrams, it has a do in it, and that's how you know that this is a transition action. So when you're starting to specify what side effects should happen in when they should happen.

Like I said, I really recommend putting them on the transition first. So for example, when we loaded we want to start playing the audio. And when we pause, we wanna pause the audio but notice that, okay. Over here when we're paused in the play event happens, we want to play the audio as well.

So now look at these two events over here. These two events are interesting because they are doing the same thing and it's showing you that any transition that goes into the playing state needs to execute those events. And so that's how you know that that's actually a candidate for having an entry event.

[COUGH] So, use entry events when you realize that every single transition to the states results in that action being taken, same thing with exit events or sorry exit actions. If you notice that every single transition out of the states results in this exit action, then or results in this action, then you should convert that to an exit action.

So for example, if we have do pause audio but we realize that anytime that we're exiting this playing state, this pause audio happens. And so let me just make another example over here. So let's say that we're playing. And let's say that we have this dreaded, gonna color this.

We have this dreaded buffering events, which we're not gonna model in our actual state machine, but just lets pretend it happens. If we only have pause audio on this pause event, we need to duplicate it over here because we also want to pause the audio if it's buffering because obviously there's no audio to play.

And so now we know this that every single exit events, or sorry, yet every single exit transition on the state note is going to cause this same pause audio events. That's a candidate for instead having exit pause audio and removing these two. So in summary using entry and exit actions is a way to dry up your state machine logic but starts by specifying the actions on the transitions themselves first.

Alright, so the way that we specify these actions on the states or the transitions is by, here I'll add over here, is by specifying it in line at first. And so this is going to be the first thing we're doing over here. I'm going to go to the scratchpad, okay, so again we have our simple machine we have our loading machine and on success loaded let's make this a target over loaded.

So in this state objects, we could specify entry actions and we could specify multiple actions as well. So, an action can either look like a string, so we could say, load data, or it could be an object. In this way, it allows you to have parameters, just whatever you want.

But in this case, we're just gonna have it as a string just to keep things simple. All right, so now, if we go back to the homepage, we're gonna see that it shows loading over here, but I also want to log the states.actions. And so now we're going to see that we entered the loading state and now we have an array of actions.

Notice how it converted it to an object over here we have a type of load data. And that's gonna do something we haven't specified what it's going to do yet, but that shows us that this action is meant to be executed. Now, the state machine transition function will not execute actions, the interpreter will and that's one of the roles of the interpreter is not only persisting the current state, but also executing actions too.

So if instead we change this to an inline function. And we say consult.log loading data. Then you'll see here that this loading data message appears because we're entering that state and executing this action which it's going to console dot log it out. And so we could do the same thing for transitions, so I could have an action over here, actions.

And I'm just gonna do an inline action again, and say console.logdataloaded. Or I might do something like assigning data which we're gonna be doing in the future lesson. So now it says loading data. And if I send type success, that just shows you the same machine is working.

Now we see it says assigning data. And that's because it's executing that inline transition action. Now, you as a refactor target, you don't have to specify all of your actions in line. Instead what you could do is, for example, let's have load data, the machine itself has a withconfig method that allows you to specify the implementation details of these actions and other things as well.

So if I put actions as an object here, and we say, load data, And then we console.log configured loading data. Then we should see that this configured loading data message shows, and that's because it is reading from these implementation details. So those are the ways to specify actions either in Entry Exit or transition actions over here and I do recommend that you specified them as an array.

Because there is always the chance that you might need to execute multiple actions inside your transitions or in entry or exit other states.

```js
import './style.css';

import { createMachine, interpret } from 'xstate';

const machine = createMachine({
    initial: 'loading',
    states: {
        loading: {
            entry: ['loadingData'],
            exit: [],
            on: {
                SUCCESS: {
                    actions: [() => {
                        console.log('Assigning data')
                    }],
                    target: 'loaded'
                }
            }
        },
        loaded: {}
    }
}).withConfig({
    actions: {
        loadingData: () => {
            console.log('configured loading data')
        }
    }
});

const service = interpret(machine).start();

service.subscribe(state => {
    console.log(state.value)
})

window.service = service;

```

#### Actions Exercise

Inside this exercise, we have a pretty fleshed out player machine. And so, this player machine is doing what we did in the previous exercise, but we actually need it to start doing stuff. And we don't know exactly what the implementation details of that stuff is gonna be.

So we are just going to put some stub actions in there for now. So on the loaded state, we want to add an action that assigns the song data. And we're gonna cover what that means in the next lesson, but you could just add a console.log there. And then we're going to be adding two actions in the playing state.

So whenever the playing state is entered, we need to add an action to play the audio. And so when the state is exited, we want to add the action to pause the audio. Now, we have a few more actions over here, and this is something I wanna talk about too.

That you could specify this on object on the routes of the machine. And so what this is going to mean is that these events should be handled, no matter what state you're in, unless they are overwritten by another states. But yeah, so for now, just realize that these events can be handled whether you're in the loading, playing or paused state, and we could customize that behavior later.

So in the skip states, we're going to skip the song, so again, just make a dummy action that console logs I'm skipping the song. We also have the option to like or unlike a song. These are also actions that don't go to a specific state, but they're just side effects that are done.

And we have a dislike action, now this is actually interesting because if we go to, I think it's testing, you'll notice that, sure, we could like a song, but when we dislike a song, it needs to do two things. It needs to mark the song it's disliked, and also skip to the next song.

Because, obviously, if a song is disliked, we want to stop listening to it. So this is where the actions array is going to come in handy. So we also want to add an action to the volume. And if you want, and if you have time, specify the actions in withConfig over here.

Now there's one more thing that I want to mention for this exercise. And that's that you can also raise an event. And so this is an example of a built in action in XState. So we're gonna import raise from xstate/lib/actions. And so, this is actually a really useful technique, because when you raise an event, that event is sent to the machine itself.

It's like you as a person telling yourself or reminding yourself to do something, same thing with the machine. The machine can tell itself to do something. So, for example, I'm just gonna make a BLAH event over here, this is just a demo, so the names don't really matter.

I'm going to raise a success event, so type SUCCESS. And so now, When I'm in loading, and I send, instead of type SUCCESS, I send type BLAH, it's gonna go to loaded. And the reason it goes to loaded is because it's going to execute this transition and one of the actions is to raise this event.

So this event is going to be sent to the machine itself, and it's going to now execute this transition. So the raise action creator is really useful.

```js
import { createMachine, actions } from 'xstate';
const { raise } = actions;

const raiseActionDemo = createMachine({
  id: 'raisedmo',
  initial: 'entry',
  states: {
    entry: {
      on: {
        STEP: {
          target: 'middle'
        },
        RAISE: {
          target: 'middle',
          // immediately invoke the NEXT event for 'middle'
          actions: raise('NEXT')
        }
      }
    },
    middle: {
      on: {
        NEXT: { target: 'last' }
      }
    },
    last: {
      on: {
        RESET: { target: 'entry' }
      }
    }
  }
});
```

Click on both `STEP` and `RAISE` events in the [visualizer)](https://stately.ai/viz?gist=fd763ff2c161b172f719891e2544d428)to see the difference

#### Actions Solution

For now, the simplest way to get started with actions is to actually just implement them inline. So for example, on the loaded state, we see that we have to add an action here to assign the song data. And so for now, I'm just going to say actions, and I could specify this as an inline function and to say console.log assigning song data.

And so now when I go to actions, it says, assigning song data because that loaded event is being sent at the bottom over here. Now, what we could do is we could serialize this and say that instead, we just want this to be a named action and call it assignSongData.

And then we could specify it in withConfig over here. So we could say, assignSongData and just have the same thing, console.log assigning song data. And so same thing should be happening. Just make sure, yep, assigning song data. So now that's something that you could do for the rest of the actions over here.

Of course, an entry action is going to be the same format, just with a different property name. We have entry actions, or sorry, not actions, but just playAudio. And so same thing with exit. Instead of play, we have pauseAudio. So we have assigning song data and, We have this playAudio and pauseAudio action.

We're not console.logging it yet, but you could see over here that we subscribed and we're logging the state.actions. So we should see that, okay, when the song is loaded, we're doing two actions. We're assigning the song data, and we're playing the audio. So now if I pause, one action is gonna happen, which is that pauseAudio action.

And again, you could specify the implementation details inside of the actions over here. Now there was one event that is supposed to cause multiple actions. Let's see how we could do that. So because we specify our actions in an array, we could have something like dislike song. And we could also raise the skip event.

Because that's a built-in event, we could just specify it right over here, so raise type SKIP. So let's see what happens if we dislike the song. Look at our array. We have dislikeSong, and we also have pauseAudio. So what exactly happened over there? Well, this skip event takes us to the loading states, and this should actually be .loading.

And the loading state, so I'm gonna dislike it again. The loading state goes out of the playing state, so this exit action is gonna happen as well, and so we have pauseAudio. Now, this really highlights the value of why raise events are useful is because if we were to have skip functionality elsewhere, like we have over here in two places, both with the skip event and dislike.

Now we don't have to copy and paste that logic. Instead, we could represent it in a more abstract and dry way, which is to say when the dislike event happens, we want to dislike the song and we also want this machine to behave as if a skip event was sent to it.

And so it sends itself a skip event, and it does all the logic there. So now it becomes really easy to centralize this skip logic into this transition. And so now you don't have to repeat yourself everywhere. So let's say that we wanted skip to do something else.

We want to add actions. We want to add a condition to the skip. We could do it all in here instead of having to copy and paste all of those different things inside the dislike action or the dislike transition as well. I'm not going to do the rest, but you could take a look at main.final.js and see how it's done.

One common pattern with XState is that for things that might take multiple objects, you can pass in an array or not. I recommend you be consistent, though, in passing an array just so that it becomes easier for you to add another action if you desire. So looking at the rest of this, it's all pretty much the same thing.

We have our actions over here. Again, put them in an array if you'd like, which makes multiple actions easier. We have raise SKIP. And because this is an event without payload, we are representing it just as a string. But if you want to be consistent, you could also just provide the entire event object in there.

And then we have a bunch of actions over here, and this is something that we're going to fill in for the most parts in the next exercise.

```js
// @ts-check
import '../style.css';
import { createMachine, assign, interpret, send } from 'xstate';
import { raise } from 'xstate/lib/actions';
import elements from '../utils/elements';

const playerMachine = createMachine({
  initial: 'loading',
  states: {
    loading: {
      on: {
        LOADED: {
          // Add an action here to assign the song data
          actions: [
            'assignSongData',
            'anotherActions'
          ],
          target: 'playing',
        },
      },
    },
    paused: {
      on: {
        PLAY: { target: 'playing' },
      },
    },
    playing: {
      // When this state is entered, add an action to play the audio
      entry: [
        'playAudio'
      ],
      // When this state is exited, add an action to pause the audio
      exit: [
        'pauseAudio'
      ],
      on: {
        PAUSE: { target: 'paused' },
      },
    },
  },
  on: {
    SKIP: {
      // Add an action to skip the song
      target: 'loading',
    },
    LIKE: {
      // Add an action to like the song
    },
    UNLIKE: {
      // Add an action to unlike the song
    },
    DISLIKE: {
      // Add two actions to dislike the song and raise the skip event
      actions: [
        'dislikeSong',
        raise({
          type: 'SKIP'
        })
      ]
    },
    VOLUME: {
      // Add an action to assign to the volume
    },
  },
}).withConfig({
  actions: {
    // Add implementations for the actions here, if you'd like
    // For now you can just console.log something
    assignSongData: () => {
      console.log('assign Song Data');
    },
    playAudio: () => {
      console.log('playAudio');
    },
    pauseAudio: () => {
      console.log('pauseAudio');
    },
    dislikeSong: () => {
      console.log('dislikeSong')
    },
    anotherActions: () => {

    }
  },
});

elements.elPlayButton.addEventListener('click', () => {
  service.send({ type: 'PLAY' });
});
elements.elPauseButton.addEventListener('click', () => {
  service.send({ type: 'PAUSE' });
});
elements.elSkipButton.addEventListener('click', () => {
  service.send({ type: 'SKIP' });
});
elements.elLikeButton.addEventListener('click', () => {
  service.send({ type: 'LIKE' });
});
elements.elDislikeButton.addEventListener('click', () => {
  service.send({ type: 'DISLIKE' });
});

const service = interpret(playerMachine).start();

service.subscribe((state) => {
  console.log(state.actions);

  elements.elLoadingButton.hidden = !state.matches('loading');
  elements.elPlayButton.hidden = !state.can({ type: 'PLAY' });
  elements.elPauseButton.hidden = !state.can({ type: 'PAUSE' });
});

service.send('LOADED');

```

#### Actions Q&A

One of the questions asked, was raised, sounds like a way for a child state to send events to the parent states. Can I use it for that, too? The short answer is yes, and that's exactly what we're going to be doing in the compound states lesson. And so again, raising an event makes it so that even if the child is handling a different event but it needs the machine to behave as if another event handled in potentially a different state.

But with handle it then raising event basically lets you abstract that away. So updates should not be performed solely on the value of the target, they should only be performed on an action. So I'm interpreting updates to mean what is shown in the UI, and also what side effects are executed.

Side effects which are things that are done externally, those should always be done in actions. Now the way that UI changes, we could have just what we consider to be implicit actions. And react, and other frameworks sort of just abstract this away for you, because anytime we're changing something in the UI, that is actually an action or side effect.

It's just that we abstract that away in a declarative view layer, which is what react and view and other popular frameworks provide. So over here we're just synchronizing the UI to the state, and that's based on the actual state, like Loading, Play, Pause. Now if we want to get really granular, we could do something like when we enter the loading state, show the Loading button when we exit the loading state, hide the loading button.

But that's gonna get very verbose very quickly. And so that's, again, why frameworks exist, and why right now we're just synchronizing the state with those attributes. So it's up to you to decide whether you want to represent updates as actions, or as just synchronizing with state. But yeah, just keep in mind that external side effects should be done in actions, or actions executed in sequence will Raise skip, only start executing after dislike song is done.

So, yeah, the way that this works, and, in fact, I'm gonna take this and I'm gonna copy it. And we are going to put this inside the visualizer so that we could just take a look at it. Let's import Raise from next day live actions. All right, so the way that the actions are going to be executed, for example, when we're in the loading state, and the loaded event happens, now we're in the playing states, and let's say we want to skip this song.

What's gonna happen is that skip song, because it's a transition action, that's going to be executed first. And since we're exiting the playing states, now the Pause Audio action is going to happen. I'm pretty sure, and also you should not be super dependent on the order of actions.

Assume that the actions are going to be run at the same time even though they're not run concurrently, just don't depend too much on the order of actions. If you do want actions to run in sequence, like this action needs to run before this one, then that's something that should be represented in separate states.

So that it is % clear and precise which actions are going to execute when. Another question, I'm curious why X state has many ways to do the same thing. It seems there's a preferred way, so why allow so many ways such as inline actions versus using with config, etc.

So part of this is just the evolution of the X state. It's a state machine and state chart's library that's about six years old. So it's gone through a lot of iteration, and also it's about the purpose of what you use it for. So X state is meant to be like this hybrid of allowing you to model your states and your logic, and also allowing you to implement it.

So just like we're doing in this lesson, we're implementing our actions in the nice and quick way. Like, I honestly appreciate that I could just type in whatever action, and worry about the implementation later. Because this is something that can be immediately visualized, handed off to someone without having to think I actually didn't implement that yet so I can't share with you the diagram or the model that we're gonna be programming against.

So, I also want to say, too, that if X state only allowed one way, it would be very verbose. So for example, actions, let's say that every action required a type, which this is what it's converted to, and the actions can have multiple actions inside of them. So this is how you would have to type everything, and so for example this target, or yeah, the target is already playing this, you'd have to put it in an array.

So I do see the benefit of staying consistent, and that's something that I've heard in the past. However, as a prototyping tool, that becomes a friction point. And so that's why X state does have a couple of different ways of doing the same thing. In the future with X state version  and other helper libraries on top of X state, it's going to make it easier to enforce a single way of doing something.

And also, we are going to be updating the docs and we're gradually doing so already, where we only emphasize one way of doing things such as typing your actions, or putting your states in. But the key is that we want you to be able to move fast with actually modeling your application, instead of having to drown yourself in a bunch of syntax that you might not need.

Another question in the chat, can you recap what Raise does in how it compares to send? And so that's something that we're also going to be talking about in the last lesson, or second to the last lesson, on actors, is that Raise is a machine sending events to itself.

Send is either a machine sending an event to itself, or sending an event to another machine. I recommend you use Raise if you're sending events to yourself, and you Send if you're sending events to another actor, or machine which is an actor. So, that's in short the difference there, and in version  we're going to consolidate it so that Send becomes Sent To, and really becomes an action for sending to a separate actor.

And encouraging the use of rays in order to send in events to the machine itself. And another question, does Raise work with parallel states, too? We're gonna be talking about parallel states in the future lesson, but yes, Raise works everywhere.

```js
import { createMachine, assign, interpret, send } from "xstate";
import { raise } from "xstate/lib/actions";

const playerMachine = createMachine({
  initial: "loading",
  states: {
    loading: {
      on: {
        LOADED: {
          // Add an action here to assign the song data
          actions: ["assignSongData", "anotherActions"],
          target: "playing",
        },
      },
    },
    paused: {
      on: {
        PLAY: { target: "playing" },
      },
    },
    playing: {
      // When this state is entered, add an action to play the audio
      entry: ["playAudio"],
      // When this state is exited, add an action to pause the audio
      exit: ["pauseAudio"],
      on: {
        PAUSE: { target: "paused" },
      },
    },
  },
  on: {
    SKIP: {
      // Add an action to skip the song
      actions: ["skipSong"],
      target: "loading",
    },
    LIKE: {
      // Add an action to like the song
      actions: ["likeSong"],
    },
    UNLIKE: {
      // Add an action to unlike the song
      actions: ["unlikeSong"],
    },
    DISLIKE: {
      // Add two actions to dislike the song and raise the skip event
      actions: [
        "dislikeSong",
        raise({
          type: "SKIP",
        }),
      ],
    },
    VOLUME: {
      // Add an action to assign to the volume
      actions: ["assignVolume"],
    },
  },
}).withConfig({
  actions: {
    // Add implementations for the actions here, if you'd like
    // For now you can just console.log something
    assignSongData: () => {
      console.log("assign Song Data");
    },
    playAudio: () => {
      console.log("playAudio");
    },
    pauseAudio: () => {
      console.log("pauseAudio");
    },
    dislikeSong: () => {
      console.log("dislikeSong");
    },
    anotherActions: () => {},
    skipSong: () => {
      console.log("skipSong");
    },
    likeSong: () => {
      console.log("likeSong");
    },
    unlikeSong: () => {
      console.log("unlikeSong");
    },
    assignVolume: () => {
      console.log("assignVolume");
    },
  },
});

```

![image-20230314111307124](image-20230314111307124.png)

### Context

#### Context

When we were talking about modeling in the first lesson, we were describing states or finite states in particular as representing the different behaviors of your application. So what do we do with the extra states that we're used to knowing? So this is sort of the difference between qualitative and quantitative state.

Where qualitative means it describes something like a mode or a status of your app that determines the behavior, and then quantitative more describes things that don't really have anything to do directly with the states. For example going back to me as a state machine, I can be either asleep or awake and that determines my behavior.

But I could also have different attributes like my height or my age which more or less don't really affect the behavior directly. They're not specific ways of categorizing my behavior, they're just attributes of me. Or my favorite color, my eye color, things like that. So in xstate we represent this so called extended state or state that's not finite state in context.

And we could update that context using an assign action creator. And then we can read from the context via state.context. So let's take a look at how this looks in an actual application. I'm going to go back to the machine that I created in our sandbox over here.

And the way we add a context, which is our initial data so to speak for the machine, is by specifying the initial context in the context property of the machine. So I could say for example count . And so now in my app when I'm reading and when we're going to actually read the context.

When we're reading the state, we could read the state.context and get that data. So over here it's logging count , just because that is exactly what we specified in the state.context. Now what if we want to actually to modify that context. Well, we use an action to do so.

So I'm gonna create an assign action here and I'm gonna pull this in from xstate. And then the easiest way to do this is to pass an object in here and the parts of the context that you want to change go in that object over here. So we could say counts, and let's just change this now to a .

All right, so the count is still . But now if I send SUCCESS, which is where that action is defined, the counts changes to . Now this is changing it to a static value. You could also change it to a value depending on what the current context and the events that was passed in gives you.

So we could increment the counts by saying, just gonna say context.count + . And so now we send SUCCESS, the count is . Especially if we have events with a payload, we could base it on that events payload as well. So let's say that we have in events.value and so we have to add that payload, so we're just gonna say value .

So now that's going to take the current context, count, and it's going to add  to it. And so now you could see the count is . Yeah, so keep in mind that even if you have other properties in here, such as, name David, those aren't affected by this assign action because in this case we're only modifying the counts.

So if I add a  again, I still have the name of David, and the count is .

```js
// @ts-check
import '../style.css';
import { createMachine, assign, interpret, send } from 'xstate';
import elements from '../utils/elements';
import { raise } from 'xstate/lib/actions';
import { formatTime } from '../utils/formatTime';

const playerMachine = createMachine({
  initial: 'loading',
  context: {
    // Add initial context here for:
    // title, artist, duration, elapsed, likeStatus, volume
    count: 42
  },
  states: {
    loading: {
      on: {
        LOADED: {
          // actions: 'assignSongData',
          actions: [
            assign({
              // count: 100
              count: (context, event) => {
                return context.count + 1 + event.type
              }
            })
          ],
          target: 'playing',
        },
      },
    },
    paused: {
      on: {
        PLAY: { target: 'playing' },

      },
    },
    playing: {
      entry: 'playAudio',
      exit: 'pauseAudio',
      on: {
        PAUSE: { target: 'paused' },
      },
    },
  },
  on: {
    SKIP: {
      actions: 'skipSong',
      target: 'loading',
    },
    LIKE: {
      actions: 'likeSong',
    },
    UNLIKE: {
      actions: 'unlikeSong',
    },
    DISLIKE: {
      actions: ['dislikeSong', raise('SKIP')],
    },
    VOLUME: {
      actions: 'assignVolume',
    },
    'AUDIO.TIME': {
      actions: 'assignTime',
    },
  },
}).withConfig({
  actions: {
    assignSongData: assign({
      // Assign the `title`, `artist`, and `duration` from the event.
      // Assume the event looks like this:
      // {
      //   type: 'LOADED',
      //   data: {
      //     title: 'Some title',
      //     artist: 'Some artist',
      //     duration: 123
      //   }
      // }
      // Also, reset the `elapsed` and `likeStatus` values.
    }),
    likeSong: assign({
      // Assign the `likeStatus` to "liked"
    }),
    unlikeSong: assign({
      // Assign the `likeStatus` to 'unliked',
    }),
    dislikeSong: assign({
      // Assign the `likeStatus` to 'disliked',
    }),
    assignVolume: assign({
      // Assign the `volume` to the `level` from the event.
      // Assume the event looks like this:
      // {
      //   type: 'VOLUME',
      //   level: 5
      // }
    }),
    assignTime: assign({
      // Assign the `elapsed` value to the `currentTime` from the event.
      // Assume the event looks like this:
      // {
      //   type: 'AUDIO.TIME',
      //   currentTime: 10
      // }
    }),
    skipSong: () => {
      console.log('Skipping song');
    },
    playAudio: () => {},
    pauseAudio: () => {},
  },
});

const service = interpret(playerMachine).start();
window.service = service;

elements.elPlayButton.addEventListener('click', () => {
  service.send({ type: 'PLAY' });
});
elements.elPauseButton.addEventListener('click', () => {
  service.send({ type: 'PAUSE' });
});
elements.elSkipButton.addEventListener('click', () => {
  service.send({ type: 'SKIP' });
});
elements.elLikeButton.addEventListener('click', () => {
  service.send({ type: 'LIKE' });
});
elements.elDislikeButton.addEventListener('click', () => {
  service.send({ type: 'DISLIKE' });
});

service.subscribe((state) => {
  console.log(state.context);
  const { context } = state;

  elements.elLoadingButton.hidden = !state.hasTag('loading');
  elements.elPlayButton.hidden = !state.can({ type: 'PLAY' });
  elements.elPauseButton.hidden = !state.can({ type: 'PAUSE' });
  elements.elVolumeButton.dataset.level =
    context.volume === 0
      ? 'zero'
      : context.volume <= 2
      ? 'low'
      : context.volume >= 8
      ? 'high'
      : undefined;

  elements.elScrubberInput.setAttribute('max', context.duration);
  elements.elScrubberInput.value = context.elapsed;
  elements.elElapsedOutput.innerHTML = formatTime(
    context.elapsed - context.duration
  );

  elements.elLikeButton.dataset.likeStatus = context.likeStatus;
  elements.elArtist.innerHTML = context.artist;
  elements.elTitle.innerHTML = context.title;
});

service.send({
  type: 'LOADED',
  data: {
    title: 'Some song title',
    artist: 'Some song artist',
    duration: 100,
  },
});

```

#### Context Exercise

So now, we're gonna be jumping to an exercise on context, and so in this exercise we want to do a few things to actually make our our machine a little bit more useful than something that just toggles between play and pause. So we're going to add the initial context first for the song title and artist which could be undefined at first.

The total duration of the song which, again, we don't know so it starts at  the elapsed value which is how far along we're at the in the song which can be , the like status which is a string, and that like status can be either unliked or it could be liked.

Oops, liked or it could be disliked. And yeah, there's three different values for that. And then the volume which is a number. So you're going to add that initial context into there. And then we are going to change some of the actions so that they're actually assigning to context.

The assigned song data. We're going to assume that it takes an events with type loaded in this data in the payload, and you're going to assign the title, artist duration, and you're going to reset the elastine like status values. Try to see how many of these assign actions you could get to, we're gonna take a short time to do this and if you don't get to all of them that's fine, I just want to get you used to writing these assigned actions.

So yeah, in this assign time is another action that's going to be reading directly from the events, just getting you used to setting the initial context and also assigning it via an action. Keep in mind too, that when we render this out, that context is actually read just like we talked about from states.context and is used inside the application to display certain things, and we'll talk about that after we're done with the exercise.

### Guards



### Compound States



### Parallel States



### Final States



### History States



### Actor Model



### Wrapping Up

## `xstate`

### 第一个状态机

> 可直接参考官方api

[入门 | XState 文档 (lecepin.github.io)](https://lecepin.github.io/xstate-docs-cn/zh/guides/start.html#我们的第一个状态机)

新建`vue`项目，新建`src/utils/xstate.js`，按照上述教程入门

```js
import { createMachine } from "xstate"; // 这是一个创建状态机的函数。
const promiseMachine = createMachine({
    id: "promise", // 去标识状态机
    initial: "pendding", // 指定这台状态机应该处于的初始状态节点
    states: { //  定义每个子状态 pendding resolved rejected
        pendding: {
            on: { // 向状态节点添加 转换（transitions）
                RESOLVE: { target: "resolved" },
                REJECT: { target: "rejected" },
            },
        },
        resolved: {
            type: "final" // 将 resolved 和 rejected 的状态节点标记为 最终状态节点，因为 promise 状态机一旦达到这些状态就会终止运行
        },
        rejected: {
            type: "final"
        },
    },
});
```

`vscode`中安装可视化插件，装完后右下角有个提示，点击允许

![image-20230308170948962](image-20230308170948962.png)

上述代码给定了`id`、初始状态、子状态、`transitions`、最终状态，此时就可以点击下图所示按钮，进行可视化查看

![image-20230308171034095](image-20230308171034095.png)



### 运行状态机

如何运行我们的状态机，取决于我们计划在哪里使用它

[运行我们的状态机](https://lecepin.github.io/xstate-docs-cn/zh/guides/start.html#运行我们的状态机)

#### 浏览器中使用

你可以直接从 [unpkg CDN (opens new window)](https://unpkg.com/xstate@4/dist/)中包含 XState：

- XState core: https://unpkg.com/xstate@4/dist/xstate.js

- XState web:https://unpkg.com/xstate@4/dist/xstate.web.js

  - 浏览器兼容，ES module 构建

  ```html
  <script src="https://unpkg.com/xstate@4/dist/xstate.js"></script>
  ```

  变量 `XState` 将在全局范围内可用，这将使你能够访问顶级导出。

  ```html
  <!DOCTYPE html>
  <html lang="en">
  
  <head>
      <meta charset="UTF-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Document</title>
  </head>
  
  <body>
      <script src="https://unpkg.com/xstate@4/dist/xstate.js"></script>
      <script>
          const {
              createMachine,
              actions,
              interpret
          } = XState;
          const promiseMachine = createMachine({
              id: "promise",
              initial: "pendding",
              states: {
                  pendding: {
                      on: {
                          RESOLVE: {
                              target: "resolved"
                          },
                          REJECT: {
                              target: "rejected"
                          },
                      },
                  },
                  resolved: {
                      type: "final"
                  },
                  rejected: {
                      type: "final"
                  },
              },
          });
          const promiseServlice = interpret(promiseMachine).onTransition(state => {
              console.log(state.value);
          });
          promiseServlice.start();
          promiseServlice.send({
              type: 'RESOLVE'
          });
      </script>
  </body>
  
  </html>
  ```

  

#### 在 Node/Vanilla JS

为了 `解释（interpret）` 状态机并使其运行，我们需要添加一个解释器。这将创建一个服务：

```js
import { createMachine, interpret } from 'xstate';

const promiseMachine = createMachine({
  /* ... */
});

const promiseService = interpret(promiseMachine).onTransition((state) =>
  console.log(state.value)
);

// 开启 service
promiseService.start();
// => 'pending'

promiseService.send({ type: 'RESOLVE' });
// => 'resolved'
```

#### 与`Vue`一起使用

[与 Vue 一起使用 | XState 文档 (lecepin.github.io)](https://lecepin.github.io/xstate-docs-cn/zh/recipes/vue.html)

[@xstate/vue | XState Docs](https://xstate.js.org/docs/packages/xstate-vue/#quick-start)

1. Install `xstate` and `@xstate/vue`:

```bash
npm i xstate @xstate/vue
```

Vue follows a similar pattern to [React](https://lecepin.github.io/xstate-docs-cn/zh/recipes/react.html):

- The machine can be defined externally;
- The service is placed on the `data` object;
- State changes are observed via `service.onTransition(state => ...)`, where you set some data property to the next `state`;
- The machine's context can be referenced as an external data store by the app. Context changes are also observed via `service.onTransition(state => ...)`, where you set another data property to the updated context;
- The service is started (`service.start()`) when the component is `created()`;
- Events are sent to the service via `service.send(event)`.

定义`js`

```js
import { createMachine } from 'xstate';

// This machine is completely decoupled from Vue
export const toggleMachine = createMachine({
  id: 'toggle',
  context: {
    /* some data */
  },
  initial: 'inactive',
  states: {
    inactive: {
      on: { TOGGLE: 'active' }
    },
    active: {
      on: { TOGGLE: 'inactive' }
    }
  }
});
```

定义组件

```vue
<!-- Toggle.vue -->
<template>
  <button v-on:click="send('TOGGLE');">
    {{ current.matches("inactive") ? "Off" : "On" }}
  </button>
</template>

<script>
  import { interpret } from 'xstate';
  import { toggleMachine } from '../path/to/toggleMachine';

  export default {
    name: 'Toggle',
    created() {
      // Start service on component creation
      this.toggleService
        .onTransition((state) => {
          // Update the current state component data property with the next state
          this.current = state;
          // Update the context component data property with the updated context
          this.context = state.context;
        })
        .start();
    },
    data() {
      return {
        // Interpret the machine and store it in data
        toggleService: interpret(toggleMachine),

        // Start with the machine's initial state
        current: toggleMachine.initialState,

        // Start with the machine's initial context
        context: toggleMachine.context
      };
    },
    methods: {
      // Send events to the service
      send(event) {
        this.toggleService.send(event);
      }
    }
  };
</script>
```



### 状态机和状态图简介

状态图（statecharts）是一种图形语言，它用来描述过程中的状态。

你可能也用过类似的图，来设计用户流程图、规划数据库、或者构建 APP 架构。状态图（statecharts）是换种方式，用一堆盒子和箭头，来给人展示什么叫流程。不过，有了 XState，我们就能用代码来管理应用逻辑了。

这篇指南，会用初学者友好的方式，给你讲讲状态图（statecharts） 基础，内容如下：

- [状态 states](https://lecepin.github.io/xstate-docs-cn/zh/guides/introduction-to-state-machines-and-statecharts/#states)
- [转换与事件 transitions and events](https://lecepin.github.io/xstate-docs-cn/zh/guides/introduction-to-state-machines-and-statecharts/#transitions-and-events)
- [初始状态 initial states](https://lecepin.github.io/xstate-docs-cn/zh/guides/introduction-to-state-machines-and-statecharts/#initial-state)
- [最终状态 final states](https://lecepin.github.io/xstate-docs-cn/zh/guides/introduction-to-state-machines-and-statecharts/#final-state)
- [复合状态 compound states](https://lecepin.github.io/xstate-docs-cn/zh/guides/introduction-to-state-machines-and-statecharts/#compound-states)
- [并行状态 parallel states](https://lecepin.github.io/xstate-docs-cn/zh/guides/introduction-to-state-machines-and-statecharts/#parallel-states)
- [自转换 self-transitions](https://lecepin.github.io/xstate-docs-cn/zh/guides/introduction-to-state-machines-and-statecharts/#self-transition)
- [计划状态图 planning statecharts](https://lecepin.github.io/xstate-docs-cn/zh/guides/introduction-to-state-machines-and-statecharts/#planning-statecharts)
- [延迟状态图 delayed transitions](https://lecepin.github.io/xstate-docs-cn/zh/guides/introduction-to-state-machines-and-statecharts/#delayed-transitions)
- [动作 actions](https://lecepin.github.io/xstate-docs-cn/zh/guides/introduction-to-state-machines-and-statecharts/#actions)

#### 状态 States

我们用圆角矩形盒子来展示 *状态*。为狗的过程，绘制状态图，首先会想到两种状态

![img](asleep-awake.a233a2ef-16783168931102.svg)

狗总是 睡着（asleep） 或 醒着（awake）。狗不能同时睡着和醒着，狗也不可能不睡不醒。只有这两种状态，没其它的了，这就是我们说的有限数量的状态。

#### 转换与事件 Transitions and event

狗在 **睡着** 和 **醒着** 之间的变化，是通过转换来表示的，它用一个箭头表示，从一个状态指向过程序列中的下一个状态

![img](transitions-events.af54e0b5.svg)

转换（transition）是由导致状态更改的 **事件（event）** 引起的。用事件来标记转换。

转换和事件是 **确定性** 的。 确定性意味着每个转换和事件总是指向相同的下一个状态，并且每次进程运行时总是从给定的起始条件产生相同的结果。 你永远不会把狗摇醒后，它还 **睡着** ，或打晕它 它还 **醒着** 吧。

小狗具有两个有限状态，和两个转换的过程，就是一个 *有限状态机*。 状态机用于描述某事物的行为。 状态机描述事物的状态，以及这些状态之间的转换。 它是一个有限状态机，因为它具有有限数量的状态。（缩写为 FSM）

#### 初始状态 Initial state

任何具有状态的事物，都会有一个 *初始状态*，即进程存在的默认状态，直到发生事件，从而改变事物的状态。

初始状态用实心圆圈表示，箭头从圆圈指向初始状态

![img](initial-state.bdbe27a5.svg)

用状态图来描述遛狗的过程，初始状态会是 **等待（waiting）** 走路。

#### 最终状态 Final state

大多数具有状态的进程都会有一个 *最终状态*，即进程完成时的最后一个状态。 最终状态由状态圆角矩形框上的双边框表示。

在遛狗状态图中，最终状态是 **溜狗完成（walk complete）**。

![Dog walking statechart showing waiting state transitioning through the leave home event to the on a walk state, then transitioning through the arrive home event to the final state of walk complete.](final-state.63512456.svg)

#### 复合状态 Compound states

复合状态是可以包含更多状态的状态，也称为子状态。 这些子状态只能在父级复合状态发生时发生。在遛狗（on a walk）状态中，可以有 **走路中（walking）**、 **奔跑中（running）** 和 **停下来闻闻好闻的气味（stopping to sniff good smells）** 几个子状态。

复合状态由标记的圆角矩形框表示，该框充当其子状态的容器。

![img](compound-state.e9bfccbb.svg)

复合状态还应指定哪个子状态是初始状态。 在 **on a walk** 状态下，初始状态为 **walking**。

复合状态使状态图能够处理比日常状态机更复杂的情况。

#### 原子状态 Atomic states

原子状态是没有任何子状态的状态。**等待（Waiting）**, **遛狗完成（walk complete）**, **走路（walking）**, **奔跑（running）** 和 **停下来闻闻好闻的（stopping to sniff good smells）** 都是原子状态。

#### 并行状态 Parallel states

并行状态是一种复合状态，其中所有子状态（也称为区域）同时处于活动状态。 这些区域在复合状态容器内由虚线分隔。

在 **on a walk** 复合状态内，可能有两个区域。 一个区域包含狗的 **walking**、 **running** 和 **stopping to sniff good smells** 的活动子状态，另一个区域包含狗的尾巴 **摇动（wagging）** 和 **不摇动（not wagging）** 状态。 狗可以走路和摇尾巴，跑和摇尾巴，或者在摇尾巴的同时停下来闻，它也可以在不摇尾巴的情况下进行任何这些活动。

![img](parallel-states.f60d5dd7.svg)

两个区域还应该指定哪个子状态是初始状态。 在我们的 **tail** 区域，初始状态是 **not wagging**。

#### 自转换 Self-transition

自转换是指事件发生但转换返回到相同状态时。 转换箭头退出并重新进入相同的状态。

描述自我转变的一种有用方法是在过程中“一直做某事，但一直没变化”。

在狗讨好的过程中，会有一个 **讨好（begging）** 状态和一个 **获得好处（gets treat）** 事件。 而对于爱吃的狗来说，无论你经历了多少次得到 **gets treat** 事件，狗都会回到 **begging** 状态。

![img](self-transition.c8ffac05.svg)

#### 计划状态图 Planning statecharts

状态图的好处之一是，在将状态图放在一起的过程中，你可以发觉过程中的所有可能状态。 这种探索将帮助你避免代码中的错误，因为能让你覆盖到所有的事件变化。

而且由于状态图是可执行的，它们既可以作为图表，也可以作为代码，从而减少在图表和编码环境之间引入差异或错误解释的可能性。

#### 为登录状态机计划一个状态图 Planning a statechart for a login machine

要绘制登录状态机的状态图，首先要列出流程中的基本事件。 想想你的登录过程会 *做* 什么：

- 登进 log in
- 登出 log out

然后列出由于这些事件而存在的 *状态*：

- 已登进 logged in
- 已登出 logged out

一旦有了一些事件和状态，状态图就开始了。

![Login statechart showing an initial logged out state transitioning through a log in event to a logged in state, then transitioning through a log out event back to the logged out state.](basic-login.c40ae416.svg)

不要忘记 *初始状态*。 在这种情况下，**logged out** 状态是初始状态，因为任何新用户都会进入未登录过程。

#### 延迟转换 Delayed transitions

作为安全措施，某些登进和登出的过程，会在固定时间后，登出非活动用户。

**活动（active）** 和 **空闲（idle）** 状态仅在用户登进时发生，因此它们成为 **登进（logged in）** 复合状态中的子状态。

![img](login-compound-state.d6d9b069.svg)

**logged in** 复合状态中的初始状态是 **active**，因为它是 **log in** 事件的直接结果，登录是用户活动的标志。

*延迟转换（delayed transition）* 是一种在处于某种状态，达到指定时间长度后，发生的转换。 延迟的转换被标记为“之后”和一个固定的持续时间，以指示在转换到下一个指示状态之前应该经过多长时间。

在登进状态图中，**60000** 毫秒或 1 分钟的延迟转换跟随 **active** 状态来确定用户是否 **idle**。 如果在转换达到一分钟之前有 **activity** 事件，则流程返回 **active** 状态。

![img](delayed-transition.352ce5a6.svg)

如果用户保持 idle 状态，则在空闲状态之后会延迟 180000 毫秒（或 3 分钟）转换到 自动登出（auto logged out） 状态。

#### 动作 Actions

状态图使用，在状态图之外系统触发的 *actions*。 动作通常也称为 *作用（effects）* 或 *副作用（side-effects）*。 “副作用”听起来像是一个消极或不重要的术语，但引发动作，是使用状态图的主要目的。

动作事件，对后续的其余部分没有影响，事件只是被触发，流程还是原来设置的那样，走下一步。 例如，登录状态图可能会执行更改用户界面的操作。

可以在进入或退出状态或转换时触发 *动作*。状态的操作包含在状态容器内，带有“entry /” 或 “exit /”标签，具体取决于动作是在进入还是退出状态时触发。

在登录状态图中，**idle** 状态有一个进入动作来警告用户他们可能会被登出。

![img](entry-action.8f5dc1ec.svg)





### 状态机 Machines

状态机是一组有限的状态，可以根据事件确定性地相互转换。 要了解更多信息，请阅读 [介绍状态图](https://lecepin.github.io/xstate-docs-cn/zh/guides/introduction-to-state-machines-and-statecharts/)。

#### 配置

状态机和状态图都是使用 `createMachine()` [工厂函数](https://www.jianshu.com/p/9ce26a5044e6)定义的：

```js
import { createMachine } from 'xstate';

const lightMachine = createMachine({
  // 状态机标识
  id: 'light',

  // 初始状态
  initial: 'green',

  // 整个状态机的本地 context
  context: {
    elapsed: 0,
    direction: 'east'
  },

  // 状态定义
  states: {
    green: {
      /* ... */
    },
    yellow: {
      /* ... */
    },
    red: {
      /* ... */
    }
  }
});
```

状态机配置与 状态节点配置 相同，增加了上下文（context）属性：

代表状态机所有嵌套状态的本地“扩展状态”。 有关更多详细信息，请参阅文档 context 文档。

#### 选项

[actions](https://lecepin.github.io/xstate-docs-cn/zh/guides/actions.html)、 [activities](https://lecepin.github.io/xstate-docs-cn/zh/guides/activities.html)、 [delays](https://lecepin.github.io/xstate-docs-cn/zh/guides/delays.html)、 [guards](https://lecepin.github.io/xstate-docs-cn/zh/guides/guards.html)、 和 [services](https://lecepin.github.io/xstate-docs-cn/zh/guides/communication.html) 的实现可以在状态机配置中作为字符串引用，然后在 `createMachine()` 的第二个参数中指定为对象：

```js
const lightMachine = createMachine(
  {
    id: 'light',
    initial: 'green',
    states: {
      green: {
        // 通过字符串引用 action
        entry: 'alertGreen'
      }
    }
  },
  {
    actions: {
      // action 执行
      alertGreen: (context, event) => {
        alert('Green!');
      }
    },
    activities: {
      /* ... */
    },
    delays: {
      /* ... */
    },
    guards: {
      /* ... */
    },
    services: {
      /* ... */
    }
  }
);
```

该对象有 5 个可选属性：

- `actions` - action 名称到它们的执行的映射
- `activities` - activities 名称与其执行的映射
- `delays` - delays 名称与其执行的映射
- `guards` - 转换守卫 (`cond`) ，名称与其执行的映射
- `services` - 调用的服务 (`src`) ，名称与其执行的映射

#### 扩展状态机

可以使用 `.withConfig()` 扩展现有状态机，它采用与上述相同的对象结构：

```js
const lightMachine = // (同上面的例子一样)

const noAlertLightMachine = lightMachine.withConfig({
  actions: {
    alertGreen: (context, event) => {
      console.log('green');
    }
  }
});
```

#### 初始化 Context

如第一个示例所示，`context` 直接在配置本身中定义。 如果要使用不同的初始 `context` 扩展现有状态机，可以使用 `.withContext()` 并传入自定义 `context`：

```js
const lightMachine = // (像第一个例子)

const testLightMachine = lightMachine.withContext({
  elapsed: 1000,
  direction: 'north'
});
```

> 注意
>
> 这 *不会* 对原始 `context` 进行浅层合并，而是将原始 `context` 替换为 `.withContext(...)` 的 `context`。 你仍然可以通过引用 `machine.context` 手动“合并”上下文：
>
> ```js
> const testLightMachine = lightMachine.withContext({
>   // 合并原始 context
>   ...lightMachine.context,
>   elapsed: 1000
> });
> ```

### 状态 State

状态是系统（例如应用）在特定时间点的抽象表示。 要了解更多信息，请阅读 [状态图简介中的状态部分](https://lecepin.github.io/xstate-docs-cn/zh/guides/introduction-to-state-machines-and-statecharts/#states)。

#### API

状态机的当前状态由一个 `State` 实例表示：

```js
const lightMachine = createMachine({
  id: 'light',
  initial: 'green',
  states: {
    green: {
      /* ... */
    }
    // ...
  }
});

console.log(lightMachine.initialState);
// State {
//   value: 'green',
//   actions: [],
//   context: undefined,
//   // ...
// }

console.log(lightMachine.transition('yellow', { type: 'TIMER' }));
// State {
//   value: { red: 'walk' },
//   actions: [],
//   context: undefined,
//   // ...
// }
```

#### State 定义

`State` 对象实例是 JSON 可序列化的，并具有以下属性：

- `value` - 当前状态的值。(例如， `{red: 'walk'}`)
- `context` - 当前状态的 [context](https://lecepin.github.io/xstate-docs-cn/zh/guides/context.html)
- `event` - 触发转换到此状态的事件对象
- `actions` - 要执行的 [动作](https://lecepin.github.io/xstate-docs-cn/zh/guides/actions.html) 数组
- `activities` - 如果 [活动](https://lecepin.github.io/xstate-docs-cn/zh/guides/activities.html) 开始，则活动映射到 `true`，如果活动停止，则映射到 `false`。
- `history` - 上一个 `State` 实例
- `meta` - 在 [状态节点](https://lecepin.github.io/xstate-docs-cn/zh/guides/statenodes.html) 的元属性上定义的任何静态元数据
- `done` - 状态是否表示最终状态

`State` 对象还包含其他属性，例如 `historyValue`、`events`、`tree` 和其他通常不相关并在内部使用的属性

####  State 方法和属性

##### `state.matches(parentStateValue)`

`state.matches(parentStateValue)` 方法确定当前 `state.value` 是否是给定 `parentStateValue` 的子集。 该方法确定父状态值是否“匹配”状态值。 例如，假设当前 `state.value` 是 `{ red: 'stop' }`：

```js
console.log(state.value);
// => { red: 'stop' }

console.log(state.matches('red'));
// => true

console.log(state.matches('red.stop'));
// => true

console.log(state.matches({ red: 'stop' }));
// => true

console.log(state.matches('green'));
// => false
```

> 提示
>
> 如果要匹配多个状态中的一个，可以在状态值数组上使用 [`.some()` ](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)来完成此操作：
>
> ```js
> const isMatch = [{ customer: 'deposit' }, { customer: 'withdrawal' }].some(
>   state.matches
> );
> ```

##### `state.nextEvents` 

`state.nextEvents` 指定将导致从当前状态转换的下一个事件：

```js
const { initialState } = lightMachine;

console.log(initialState.nextEvents);
// => ['TIMER', 'EMERGENCY']
```

`state.nextEvents` 在确定可以采取哪些下一个事件，以及在 UI 中表示这些潜在事件（例如启用/禁用某些按钮）方面很有用。

#####  `state.changed`

`state.changed` 指定此 `state` 是否已从先前状态更改。 在以下情况下，状态被视为“已更改”：

- 它的值不等于它之前的值，或者：
- 它有任何新动作（副作用）要执行。

初始状态（没有历史记录）将返回 `undefined`。

```js
const { initialState } = lightMachine;

console.log(initialState.changed);
// => undefined

const nextState = lightMachine.transition(initialState, { type: 'TIMER' });

console.log(nextState.changed);
// => true

const unchangedState = lightMachine.transition(nextState, {
  type: 'UNKNOWN_EVENT'
});

console.log(unchangedState.changed);
// => false
```

##### `state.done` 

`state.done` 指定 `state` 是否为“[最终状态](https://lecepin.github.io/xstate-docs-cn/zh/guides/final.html)” - 最终状态是指示其状态机已达到其最终状态，并且不能再转换到任何其他状态的状态。

```js
const answeringMachine = createMachine({
  initial: 'unanswered',
  states: {
    unanswered: {
      on: {
        ANSWER: { target: 'answered' }
      }
    },
    answered: {
      type: 'final'
    }
  }
});

const { initialState } = answeringMachine;
initialState.done; // false

const answeredState = answeringMachine.transition(initialState, {
  type: 'ANSWER'
});
answeredState.done; // true
```

##### `state.toStrings()` 

`state.toStrings()` 方法返回表示所有状态值路径的字符串数组。 例如，假设当前 `state.value` 是 `{ red: 'stop' }`：

```js
console.log(state.value);
// => { red: 'stop' }

console.log(state.toStrings());
// => ['red', 'red.stop']
```

`state.toStrings()` 方法对于表示基于字符串的环境中的当前状态非常有用，例如在 CSS 类或数据属性中。



##### `state.children`

`state.children` 是将生成的 服务/演员 ID 映射到其实例的对象。 详情 [📖 参考服务](https://lecepin.github.io/xstate-docs-cn/zh/guides/communication.html#referencing-services)。

**使用 `state.children` 示例**

```js
const machine = createMachine({
  // ...
  invoke: [
    { id: 'notifier', src: createNotifier },
    { id: 'logger', src: createLogger }
  ]
  // ...
});

const service = invoke(machine)
  .onTransition((state) => {
    state.children.notifier; // service 来自 createNotifier()
    state.children.logger; // service 来自 createLogger()
  })
  .start();
```

##### `state.hasTag(tag)`

*从 4.19.0 开始*

`state.hasTag(tag)` 方法，当前状态配置是否具有给定标签的状态节点。

```js
const machine = createMachine({
  initial: 'green',
  states: {
    green: {
      tags: 'go' // 单标签
    },
    yellow: {
      tags: 'go'
    },
    red: {
      tags: ['stop', 'other'] // 多标签
    }
  }
});
```

例如，如果上面的状态机处于 `green` 或 `yellow` 状态，而不是直接使用 `state.matches('green') || state.matches('yellow')`，可以使用 `state.hasTag('go')`：

```js
const canGo = state.hasTag('go');
// => 如果在 'green' 或 'yellow' 状态，返回 `true`
```

##### `state.can(event)`

*从 4.25.0 开始*

`state.can(event)` 方法确定一个 `event` 在发送到解释的(`interpret`)状态机时，是否会导致状态改变。 如果状态因发送 `event` 而改变，该方法将返回 `true`； 否则该方法将返回 `false`：

```js
const machine = createMachine({
  initial: 'inactive',
  states: {
    inactive: {
      on: {
        TOGGLE: 'active'
      }
    },
    active: {
      on: {
        DO_SOMETHING: { actions: ['something'] }
      }
    }
  }
});

const inactiveState = machine.initialState;

inactiveState.can('TOGGLE'); // true
inactiveState.can('DO_SOMETHING'); // false

// 还接收完整的 event 对象：
inactiveState.can({
  type: 'DO_SOMETHING',
  data: 42
}); // false

const activeState = machine.transition(inactiveState, 'TOGGLE');

activeState.can('TOGGLE'); // false
activeState.can('DO_SOMETHING'); // true, 因为一个 action 将被执行
```

如果 [`state.changed`](https://lecepin.github.io/xstate-docs-cn/zh/guides/states.html#state-changed) 为 `true`，并且以下任何一项为 `true`，则状态被视为“`changed`”：

- `state.value` 改变
- 有新的 `state.actions` 需要执行
- `state.context` 改变

#### 持久化`State`

如前所述，可以通过将 `State` 对象序列化为字符串 JSON 格式来持久化它：

```js
const jsonState = JSON.stringify(currentState);

// 例如: 持久化到 localStorage
try {
  localStorage.setItem('app-state', jsonState);
} catch (e) {
  // 不能保存 localStorage
}
```

可以使用静态 `State.create(...)` 方法恢复状态：

```js
import { State, interpret } from 'xstate';
import { myMachine } from '../path/to/myMachine';


// 从 localStorage 检索状态定义，如果 localStorage 为空，则使用状态机的初始状态
const stateDefinition =
  JSON.parse(localStorage.getItem('app-state')) || myMachine.initialState;

// 使用 State.create() 从普通对象恢复状态
const previousState = State.create(stateDefinition);
```

然后，你可以通过将 `State` 传递到已解释的服务的 `.start(...)` 方法，来从此状态解释状态机：

```js
// ...

// 这将在指定的状态启动 service
const service = interpret(myMachine).start(previousState);
```

这还将维护和恢复以前的 [历史状态](https://lecepin.github.io/xstate-docs-cn/zh/guides/history.html)，并确保 `.events` 和 `.nextEvents` 代表正确的值。

> 注意
>
> XState 尚不支持持久化生成的 [演员（actors）](https://lecepin.github.io/xstate-docs-cn/zh/guides/actors.html)

#### `State`元数据

元数据，是描述任何 [状态节点](https://lecepin.github.io/xstate-docs-cn/zh/guides/statenodes.html) 相关属性的静态数据，可以在状态节点的 `.meta` 属性上指定：

```js
const fetchMachine = createMachine({
  id: 'fetch',
  initial: 'idle',
  states: {
    idle: {
      on: { FETCH: { target: 'loading' } }
    },
    loading: {
      after: {
        3000: 'failure.timeout'
      },
      on: {
        RESOLVE: { target: 'success' },
        REJECT: { target: 'failure' },
        TIMEOUT: { target: 'failure.timeout' } // 手动超时
      },
      meta: {
        message: 'Loading...'
      }
    },
    success: {
      meta: {
        message: 'The request succeeded!'
      }
    },
    failure: {
      initial: 'rejection',
      states: {
        rejection: {
          meta: {
            message: 'The request failed.'
          }
        },
        timeout: {
          meta: {
            message: 'The request timed out.'
          }
        }
      },
      meta: {
        alert: 'Uh oh.'
      }
    }
  }
});
```

状态机的当前状态，收集所有状态节点的 `.meta` 数据，由状态值表示，并将它们放在一个对象上，其中：

- key 是 [状态节点 ID](https://lecepin.github.io/xstate-docs-cn/zh/guides/ids.html)
- value 是状态节点 `.meta` 的值

例如，如果上述状态机处于 `failure.timeout` 状态（由 ID 为 `“failure”` 和 `“failure.timeout”` 的两个状态节点表示），则 `.meta` 属性将组合所有 `.meta` 值，如下所示：

```js
const failureTimeoutState = fetchMachine.transition('loading', {
  type: 'TIMEOUT'
});

console.log(failureTimeoutState.meta);
// => {
//   failure: {
//     alert: 'Uh oh.'
//   },
//   'failure.timeout': {
//     message: 'The request timed out.'
//   }
// }
```

> 提示：聚合元数据
>
> 你如何处理元数据取决于你。 理想情况下，元数据应 *仅* 包含 JSON 可序列化值。 考虑以不同方式合并/聚合元数据。 例如，以下函数丢弃状态节点 ID key（如果它们不相关）并合并元数据：
>
> ```js
> function mergeMeta(meta) {
>   return Object.keys(meta).reduce((acc, key) => {
>     const value = meta[key];
> 
>     // 假设每个元值都是一个对象
>     Object.assign(acc, value);
> 
>     return acc;
>   }, {});
> }
> 
> const failureTimeoutState = fetchMachine.transition('loading', {
>   type: 'TIMEOUT'
> });
> 
> console.log(mergeMeta(failureTimeoutState.meta));
> // => {
> //   alert: 'Uh oh.',
> //   message: 'The request timed out.'
> // }
> ```



#### 笔记

- 你永远不必手动创建 `State` 实例。 将 `State` 视为仅来自 `machine.transition(...)` 或 `service.onTransition(...)` 的只读对象。
- `state.history` 不会保留其历史记录以防止内存泄漏。`state.history.history === undefined`。 否则，你最终会创建一个巨大的链表并重新发明区块链，而我们并不这样做。
  - 此行为可能会在未来版本中进行配置。

### 状态节点

状态机包含状态节点（如下所述），它们共同描述状态机可以处于的 [整体状态](https://lecepin.github.io/xstate-docs-cn/zh/guides/states.html)。在下一节描述的 `fetchMachine` 中，有 **状态节点**，例如：

```js
// ...
{
  states: {
    // 状态节点
    idle: {
      on: {
        FETCH: {
          target: 'pending';
        }
      }
    }
  }
}
```

以及整体 **状态**，即 `machine.transition()` 函数的返回值或 `service.onTransition()` 的回调值：

```js
const nextState = fetchMachine.transition('pending', { type: 'FULFILL' });
// State {
//   value: { success: 'items' },
//   actions: [],
//   context: undefined,
//   ...
// }
```

#### 什么是状态节点？

在 XState 中，**状态节点** 指定状态配置。 它们是在状态机的 `states` 属性上定义的。 同样，子状态节点在状态节点的 `states` 属性上分层定义。

从 `machine.transition(state, event)` 确定的状态，表示状态节点的组合。 例如，在下面的状态机中，有一个 `success` 状态节点和一个 `items` 子状态节点。 状态值 `{ success: 'items' }` 表示这些状态节点的组合。

```js
const fetchMachine = createMachine({
  id: 'fetch',

  // 初始 state
  initial: 'idle',

  // States
  states: {
    idle: {
      on: {
        FETCH: { target: 'pending' }
      }
    },
    pending: {
      on: {
        FULFILL: { target: 'success' },
        REJECT: { target: 'failure' }
      }
    },
    success: {
      // 初始子 state
      initial: 'items',

      // 子 states
      states: {
        items: {
          on: {
            'ITEM.CLICK': { target: 'item' }
          }
        },
        item: {
          on: {
            BACK: { target: 'items' }
          }
        }
      }
    },
    failure: {
      on: {
        RETRY: { target: 'pending' }
      }
    }
  }
});
```

#### 状态节点类型

有五种不同类型的状态节点：

- **atomic** 原子状态节点没有子状态。 （即，它是一个叶节点。）
- **compound** 复合状态节点包含一个或多个子 `states`，并有一个 `initial` 状态，这是这些子状态之一的 key。
- **parallel** 并行状态节点包含两个或多个子 `states`，并且没有初始状态，因为它表示同时处于其所有子状态。
- **final** 最终状态节点是代表抽象“终端”状态的叶节点。
- **history** 历史状态节点是一个抽象节点，表示解析到其父节点最近的浅或深历史状态。

可以在状态节点上显式定义状态节点类型：

```js
const machine = createMachine({
  id: 'fetch',
  initial: 'idle',
  states: {
    idle: {
      type: 'atomic',
      on: {
        FETCH: { target: 'pending' }
      }
    },
    pending: {
      type: 'parallel',
      states: {
        resource1: {
          type: 'compound',
          initial: 'pending',
          states: {
            pending: {
              on: {
                'FULFILL.resource1': { target: 'success' }
              }
            },
            success: {
              type: 'final'
            }
          }
        },
        resource2: {
          type: 'compound',
          initial: 'pending',
          states: {
            pending: {
              on: {
                'FULFILL.resource2': { target: 'success' }
              }
            },
            success: {
              type: 'final'
            }
          }
        }
      },
      onDone: 'success'
    },
    success: {
      type: 'compound',
      initial: 'items',
      states: {
        items: {
          on: {
            'ITEM.CLICK': { target: 'item' }
          }
        },
        item: {
          on: {
            BACK: { target: 'items' }
          }
        },
        hist: {
          type: 'history',
          history: 'shallow'
        }
      }
    }
  }
});
```

将 `type` 明确指定为 `'atomic'`、`'compound'`、`'parallel'`、`'history'`、或 `'final'` 有助于 TypeScript 中的分析和类型检查。 但是，它只需要 parallel、history 和 final 状态。

#### 瞬间状态节点

一个瞬间状态节点是一个“直通”状态节点，它会立即转换到另一个状态节点； 也就是说，状态机不会停留在瞬间状态。 瞬间状态节点可用于，根据条件确定状态机应该从先前状态真正进入哪个状态。 它们与 UML 中的 [选择伪状态](https://www.uml-diagrams.org/state-machine-diagrams.html#choice-pseudostate)最相似。

定义瞬间状态节点的最佳方法是，使用无事件状态和 `always` 转换。 这是一个转换，其中第一个为 true 的条件会立即被采用。

例如，这个状态机的初始瞬间状态解析为 `'morning'`、`'afternoon'` 右 `'evening'`，具体取决于时间（隐藏实现细节）：

```js
const timeOfDayMachine = createMachine({
  id: 'timeOfDay',
  initial: 'unknown',
  context: {
    time: undefined
  },
  states: {
    // 瞬时 state
    unknown: {
      always: [
        { target: 'morning', cond: 'isBeforeNoon' },
        { target: 'afternoon', cond: 'isBeforeSix' },
        { target: 'evening' }
      ]
    },
    morning: {},
    afternoon: {},
    evening: {}
  }
}, {
  guards: {
    isBeforeNoon: // ...
    isBeforeSix: // ...
  }
});

const timeOfDayService = interpret(timeOfDayMachine.withContext({ time: Date.now() }))
  .onTransition(state => console.log(state.value))
  .start();

// => 'morning' (假设时间在中午之前)
```

#### 状态节点元数据

元数据，是描述任何 [状态节点](https://lecepin.github.io/xstate-docs-cn/zh/guides/statenodes.html) 相关属性的静态数据，可以在状态节点的 `.meta` 属性上指定：

```js
const fetchMachine = createMachine({
  id: 'fetch',
  initial: 'idle',
  states: {
    idle: {
      on: {
        FETCH: { target: 'loading' }
      }
    },
    loading: {
      after: {
        3000: { target: 'failure.timeout' }
      },
      on: {
        RESOLVE: { target: 'success' },
        REJECT: { target: 'failure' },
        TIMEOUT: { target: 'failure.timeout' } // 手动超时
      },
      meta: {
        message: 'Loading...'
      }
    },
    success: {
      meta: {
        message: 'The request succeeded!'
      }
    },
    failure: {
      initial: 'rejection',
      states: {
        rejection: {
          meta: {
            message: 'The request failed.'
          }
        },
        timeout: {
          meta: {
            message: 'The request timed out.'
          }
        }
      },
      meta: {
        alert: 'Uh oh.'
      }
    }
  }
});
```

状态机的当前状态，收集所有状态节点的 `.meta` 数据，由状态值表示，并将它们放在一个对象上，其中：

- key 是 [状态节点 ID](https://lecepin.github.io/xstate-docs-cn/zh/guides/ids.html)
- value 是状态节点 `.meta` 的值

有关用法和更多信息，请参阅状 [状态元数据](https://lecepin.github.io/xstate-docs-cn/zh/guides/states.html#state-meta-data)。

#### 标签 Tags

状态节点可以有 **tags**，这些标签是帮助描述状态节点的字符串术语。 标签是可用于对不同状态节点进行分类的元数据。 例如，你可以使用 `"loading"` 标签来表示哪些状态节点代表正在加载数据的状态，并使用 `state.hasTag(tag)` 确定一个状态是否包含那些标记的状态节点：

```js
const machine = createMachine({
  initial: 'idle',
  states: {
    idle: {
      on: {
        FETCH: 'loadingUser'
      }
    },
    loadingUser: {
      tags: ['loading']
      // ...
    },
    loadingFriends: {
      tags: ['loading']
      // ...
    },
    editing: {
      // ...
    }
  }
});

machine.initialState.hasTag('loading');
// => false

machine.transition(machine.initialState, 'FETCH').hasTag('loading');
// => true
```

### 事件 Event

事件是导致状态机从当前 [状态](https://lecepin.github.io/xstate-docs-cn/zh/guides/states.html) [转换](https://lecepin.github.io/xstate-docs-cn/zh/guides/transitions.html) 到下一个状态的原因。 要了解更多信息，请阅读 [状态图简介中的事件部分](https://lecepin.github.io/xstate-docs-cn/zh/guides/introduction-to-state-machines-and-statecharts/#transitions-and-events)。

#### API

事件是具有 `type` 属性的对象，表示它是什么类型的事件：

```js
const timerEvent = {
  type: 'TIMER' // 约定是使用 CONST_CASE 作为事件名称
};
```

在 XState 中，只有 `type` 的事件可以由其字符串类型表示，作为速记：

```js
// 等于 { type: 'TIMER' }
const timerEvent = 'TIMER';
```

事件对象还可以有其他属性，代表与事件相关的数据：

```js
const keyDownEvent = {
  type: 'keydown',
  key: 'Enter'
};
```

#### 发送事件 Send Event

正如 [转换向导](https://lecepin.github.io/xstate-docs-cn/zh/guides/transitions.html) 中所解释的，给定当前状态和事件，转换到定义的下一个状态，在其 `on: { ... }` 属性上定义。 这可以通过将事件传递给 [transition 方法](https://lecepin.github.io/xstate-docs-cn/zh/guides/transitions.html#machine-transition-method) 来观察：

```js
import { createMachine } from 'xstate';

const lightMachine = createMachine({
  /* ... */
});

const { initialState } = lightMachine;

let nextState = lightMachine.transition(initialState, 'TIMER'); // 字符串事件
console.log(nextState.value);
// => 'yellow'

nextState = lightMachine.transition(nextState, { type: 'TIMER' }); // 事件对象
console.log(nextState.value);
// => 'red'
```

许多原生事件，例如 DOM 事件，是兼容的，可以直接与 XState 一起使用，通过在 `type` 属性上指定事件类型：

```js
import { createMachine, interpret } from 'xstate';

const mouseMachine = createMachine({
  on: {
    mousemove: {
      actions: [
        (context, event) => {
          const { offsetX, offsetY } = event;
          console.log({ offsetX, offsetY });
        }
      ]
    }
  }
});
const mouseService = interpret(mouseMachine).start();

window.addEventListener('mousemove', (event) => {
  // 事件可以直接发送到服务
  mouseService.send(event);
});
```

#### NULL 事件

> 注意
>
> null 事件语法 `({ on: { '': ... } })` 将在第 5 版中弃用。应改用新的 [always](https://lecepin.github.io/xstate-docs-cn/zh/guides/transitions.html#eventless-always-transitions) 语法

NULL 事件是没有类型的事件，一旦进入状态就会立即发生。 在转换中，它由一个空字符串 (`''`) 表示：

```js
// 人为的例子
const skipMachine = createMachine({
  id: 'skip',
  initial: 'one',
  states: {
    one: {
      on: { CLICK: 'two' }
    },
    two: {
      // 一旦进入状态，null 事件 '' 总是发生立即转换为 'three'
      on: { '': 'three' }
    },
    three: {
      type: 'final'
    }
  }
});

const { initialState } = skipMachine;
const nextState = skipMachine.transition(initialState, 'CLICK');

console.log(nextState.value);
// => 'three'
```

null 事件有很多用例，尤其是在定义 [瞬间转换](https://lecepin.github.io/xstate-docs-cn/zh/guides/transitions.html#transient-transitions) 时，状态（可能是 [瞬间状态](https://lecepin.github.io/xstate-docs-cn/zh/guides/statenodes.html#transient-state-nodes) 的）立即根据 [条件](https://lecepin.github.io/xstate-docs-cn/zh/guides/guards.html) 确定下一个状态应该是什么：

```js
const isAdult = ({ age }) => age >= 18;
const isMinor = ({ age }) => age < 18;

const ageMachine = createMachine({
  id: 'age',
  context: { age: undefined }, // age 不知道
  initial: 'unknown',
  states: {
    unknown: {
      on: {
        // 当满足 cond 条件时，立即 转换。 否则，不会发生 转换
        '': [
          { target: 'adult', cond: isAdult },
          { target: 'child', cond: isMinor }
        ]
      }
    },
    adult: { type: 'final' },
    child: { type: 'final' }
  }
});

console.log(ageMachine.initialState.value);
// => 'unknown'

const personData = { age: 28 };

const personMachine = ageMachine.withContext(personData);

console.log(personMachine.initialState.value);
// => 'adult'
```

### 转换 Transitions

转换定义了状态机如何对 [事件](https://lecepin.github.io/xstate-docs-cn/zh/guides/events.html) 做出响应。 要了解更多信息，请参阅 [状态图介绍](https://lecepin.github.io/xstate-docs-cn/zh/guides/introduction-to-state-machines-and-statecharts/#transitions-and-events) 中的部分。

#### API

状态转换在状态节点的 `on` 属性中定义，：

```js
import { createMachine } from 'xstate';

const promiseMachine = createMachine({
  id: 'promise',
  initial: 'pending',
  states: {
    pending: {
      on: {
        // 状态转换（简写）
        // 这相当于 { target: 'resolved' }
        RESOLVE: 'resolved',

        // 状态转换 (object)
        REJECT: {
          target: 'rejected'
        }
      }
    },
    resolved: {
      type: 'final'
    },
    rejected: {
      type: 'final'
    }
  }
});

const { initialState } = promiseMachine;

console.log(initialState.value);
// => 'pending'

const nextState = promiseMachine.transition(initialState, { type: 'RESOLVE' });

console.log(nextState.value);
// => 'resolved'
```

在上面的例子中，当状态机处于 `pending` 状态并且它接收到一个 `RESOLVE` 事件时，它会转换到 `resolved` 状态。

状态转换可以定义为：

- 一个字符串，例如 `RESOLVE: 'resolved'`
- 具有 `target` 属性的对象，例如 `RESOLVE: { target: 'resolved' }`,
- 转换对象数组，用于条件转换（请参阅 [守卫](https://lecepin.github.io/xstate-docs-cn/zh/guides/guards.html)）

#### 状态机 .transition 方法

如上所示， `machine.transition(...)` 方法是一个纯函数，它接受两个参数：

- `state` - 要转换的 [状态](https://lecepin.github.io/xstate-docs-cn/zh/guides/states.html)
- `event` - 导致转换的 [事件](https://lecepin.github.io/xstate-docs-cn/zh/guides/events.html)

它返回一个新的 [`State` 实例](https://lecepin.github.io/xstate-docs-cn/zh/guides/states.html#state-definition)，这是采用当前状态和事件，启用的所有转换的结果。

```js
const lightMachine = createMachine({
  /* ... */
});

const greenState = lightMachine.initialState;

// 根据当前状态和事件确定下一个状态
const yellowState = lightMachine.transition(greenState, { type: 'TIMER' });

console.log(yellowState.value);
// => 'yellow'
```

#### 选择启用转换

**启用的转换** 是将根据当前状态和事件有条件地进行的转换。 当且仅当：

- 它在与当前状态值匹配的 [状态节点](https://lecepin.github.io/xstate-docs-cn/zh/guides/statenodes.html) 上定义
- 转换 [守卫](https://lecepin.github.io/xstate-docs-cn/zh/guides/guards.html)（`cond` 属性）得到条件满足（为 `true`）
- 它不会被更具体的 转换 所取代。

在 [分层状态机](https://lecepin.github.io/xstate-docs-cn/zh/guides/hierarchical.html) 中，转换的优先级取决于它们在树中的深度； 更深层次的转换更具体，因此具有更高的优先级。 这与 DOM 事件的工作方式类似：如果单击按钮，则直接在按钮上的单击事件处理程序比 `window` 上的单击事件处理程序更具体。

```js
const wizardMachine = createMachine({
  id: 'wizard',
  initial: 'open',
  states: {
    open: {
      initial: 'step1',
      states: {
        step1: {
          on: {
            NEXT: { target: 'step2' }
          }
        },
        step2: {
          /* ... */
        },
        step3: {
          /* ... */
        }
      },
      on: {
        NEXT: { target: 'goodbye' },
        CLOSE: { target: 'closed' }
      }
    },
    goodbye: {
      on: {
        CLOSE: { target: 'closed' }
      }
    },
    closed: {
      type: 'final'
    }
  }
});

// { open: 'step1' }
const { initialState } = wizardMachine;

// 'open.step1' 上定义的 NEXT 转换取代了父'open'状态上定义的 NEXT 转换
const nextStepState = wizardMachine.transition(initialState, { type: 'NEXT' });
console.log(nextStepState.value);
// => { open: 'step2' }

// 'open.step1' 上没有 CLOSE 转换，因此事件被传递到父 'open' 状态，在那里它被定义
const closedState = wizardMachine.transition(initialState, { type: 'CLOSE' });
console.log(closedState.value);
// => 'closed'
```

#### 事件描述符

事件描述符，是描述转换 将匹配的事件类型的字符串。 通常，这等效于发送到状态机的 `event` 对象上的 `event.type` 属性：

```js
// ...
{
  on: {
    // "CLICK"是事件描述符。
    // 此转换匹配具有 { type: 'CLICK' } 的事件
    CLICK: 'someState',
    // "SUBMIT"是事件描述符。
    // 此转换匹配具有 { type: 'SUBMIT' } 的事件
    SUBMIT: 'anotherState'
  }
}
// ...
```

其他事件描述符包括：

- [Null 事件描述](https://lecepin.github.io/xstate-docs-cn/zh/guides/transitions.html#transient-transitions) (`""`)，不匹配任何事件（即 "null" 事件），并表示进入状态后立即进行的转换
- [通配符事件描述](https://lecepin.github.io/xstate-docs-cn/zh/guides/transitions.html#wildcard-descriptors) (`"*"`) <sup>4.7+</sup>，如果事件没有被状态中的任何其他转换显式匹配，则匹配任何事件

#### 自转换

自转换是当一个状态转换到自身时，它 *可以* 退出然后重新进入自身。 自转换可以是 **内部** 或 **外部** 转换：

- **内部转换** 不会退出也不会重新进入自身，但可能会进入不同的子状态。
- **外部转换** 将退出并重新进入自身，也可能退出/进入子状态。

默认情况下，具有指定目标的所有转换都是外部的。

有关如何在自转换上执行进入/退出操作的更多详细信息，请参阅有关 [自转换的操作](https://lecepin.github.io/xstate-docs-cn/zh/guides/actions.html#actions-on-self-transitions)。

#### 内部转换

内部转换是不退出其状态节点的转换。 内部转换是通过指定 [相对目标](https://lecepin.github.io/xstate-docs-cn/zh/guides/ids.html#relative-targets)（例如，`'.left'`）或通过在转换上显式设置 `{ internal: true }` 来创建的。 例如，考虑一台状态机将一段文本设置为对齐 `'left'`、 `'right'`、 `'center'`、或 `'justify'`：

```js
import { createMachine } from 'xstate';

const wordMachine = createMachine({
  id: 'word',
  initial: 'left',
  states: {
    left: {},
    right: {},
    center: {},
    justify: {}
  },
  on: {
    // 内部转换
    LEFT_CLICK: '.left',
    RIGHT_CLICK: { target: '.right' }, // 同 '.right'
    CENTER_CLICK: { target: '.center', internal: true }, // 同 '.center'
    JUSTIFY_CLICK: { target: '.justify', internal: true } // 同 '.justify'
  }
});
```

上面的状态机将以 `'left'` 状态启动，并根据单击的内容在内部转换到其他子状态。 此外，由于转换是内部的，因此不会再次执行在父状态节点上定义的 `entry`, `exit` 或者任何其他的 `actions`。

具有 `{ target: undefined }` （或无 `target`）的转换也是内部转换：

```js
const buttonMachine = createMachine({
  id: 'button',
  initial: 'inactive',
  states: {
    inactive: {
      on: { PUSH: 'active' }
    },
    active: {
      on: {
        // 无 target - 内部转换
        PUSH: {
          actions: 'logPushed'
        }
      }
    }
  }
});
```

**内部转换摘要：**

- `EVENT: '.foo'` - 内部转换到子状态
- `EVENT: { target: '.foo' }` - 内部转换到子状态（以`'.'`开头）
- `EVENT: undefined` - 禁止转换
- `EVENT: { actions: [ ... ] }` - 内部自转换
- `EVENT: { actions: [ ... ], internal: true }` - 内部自转换，同上
- `EVENT: { target: undefined, actions: [ ... ] }` - 内部自转换，同上

#### 外部转换

外部转换 *将* 退出并重新进入定义转换的状态节点。 在上面的例子中，父级 `word` 状态节点（根状态节点），将在其转换时执行 `exit` 和 `entry` 动作。

默认情况下，转换是外部的，但任何转换都可以通过在转换上显式设置 `{ internal: false }` 来实现。

```js
// ...
on: {
  // 外部转换
  LEFT_CLICK: 'word.left',
  RIGHT_CLICK: 'word.right',
  CENTER_CLICK: { target: '.center', internal: false }, // 同 'word.center'
  JUSTIFY_CLICK: { target: 'word.justify', internal: false } // 同 'word.justify'
}
// ...
```

上面的每个转换都是外部的，并且将执行父状态的 `exit` 和 `entry` 操作。

**外部转换摘要：**

- `EVENT: { target: 'foo' }` - 所有对兄弟状态的转换都是外部转换
- `EVENT: { target: '#someTarget' }` - 到其他节点的所有转换都是外部转换
- `EVENT: { target: 'same.foo' }` - 外部转换到自己的子级节点（相当于`{ target: '.foo', internal: false }`）
- `EVENT: { target: '.foo', internal: false }` - 外部转换到子节点
  - 否则这将是一个内部转换
- `EVENT: { actions: [ ... ], internal: false }` - 外部自转换
- `EVENT: { target: undefined, actions: [ ... ], internal: false }` - 外部自转换，同上

#### 瞬间转换

> 注意
>
> 空字符串语法 (`{ on: { '': ... } }`) 将在第 5 版中弃用。应该首选 4.11+ 版中新的 `always` 语法。请参阅下面关于 [无事件转换](https://lecepin.github.io/xstate-docs-cn/zh/guides/transitions.html#eventless-always-transitions) 的部分，它与瞬间转换相同。

瞬间转换是由 [null 事件](https://lecepin.github.io/xstate-docs-cn/zh/guides/events.html#null-events) 触发的转换。 换句话说，只要满足任何条件，就会 *立即* 进行转换（即，没有触发事件）：

```js
const gameMachine = createMachine(
  {
    id: 'game',
    initial: 'playing',
    context: {
      points: 0
    },
    states: {
      playing: {
        on: {
          // 瞬间转换 如果满足条件，将在（重新）进入 'playing' 状态后立即转换为 'win' 或 'lose'。
          '': [
            { target: 'win', cond: 'didPlayerWin' },
            { target: 'lose', cond: 'didPlayerLose' }
          ],
          // 自转换
          AWARD_POINTS: {
            actions: assign({
              points: 100
            })
          }
        }
      },
      win: { type: 'final' },
      lose: { type: 'final' }
    }
  },
  {
    guards: {
      didPlayerWin: (context, event) => {
        // 检查玩家是否赢了
        return context.points > 99;
      },
      didPlayerLose: (context, event) => {
        // 检查玩家是否输了
        return context.points < 0;
      }
    }
  }
);

const gameService = interpret(gameMachine)
  .onTransition((state) => console.log(state.value))
  .start();

// 仍处于 'playing' 状态，因为不满足瞬间转换条件
// => 'playing'

// 当发送“AWARD_POINTS”时，会发生自我转换到“PLAYING”。
// 由于满足“didPlayerWin”条件，因此会进行到“win”的瞬间转换。
gameService.send('AWARD_POINTS');
// => 'win'
```

就像转换一样，可以将瞬间转换指定为单个转换（例如，`'': 'someTarget'`）或条件转换数组。 如果没有满足瞬间转换的条件转换，则状态机保持相同状态。

对于每次内部或外部转换，始终 "sent" 空事件。

#### 无事件 ("Always") 转换  4.11+

无事件转换，是当状态机处于定义的状态，并且其 `cond` 守卫为 `true` 时 **始终进行** 的转换。 他们被检查：

- 立即进入状态节点
- 每次状态机接收到一个可操作的事件（无论该事件是触发内部转换还是外部转换）

无事件转换在状态节点的 `always` 属性上定义：

```js
const gameMachine = createMachine(
  {
    id: 'game',
    initial: 'playing',
    context: {
      points: 0
    },
    states: {
      playing: {
        // 无事件转换
        // 如果条件满足，将在进入 'playing' 状态或接收到 AWARD_POINTS 事件后立即转换为 'win' 或 'lose'。
        always: [
          { target: 'win', cond: 'didPlayerWin' },
          { target: 'lose', cond: 'didPlayerLose' }
        ],
        on: {
          // 自转换
          AWARD_POINTS: {
            actions: assign({
              points: 100
            })
          }
        }
      },
      win: { type: 'final' },
      lose: { type: 'final' }
    }
  },
  {
    guards: {
      didPlayerWin: (context, event) => {
        // 检测玩家是否赢了
        return context.points > 99;
      },
      didPlayerLose: (context, event) => {
        // 检测玩家是否输了
        return context.points < 0;
      }
    }
  }
);

const gameService = interpret(gameMachine)
  .onTransition((state) => console.log(state.value))
  .start();

// 仍处于 'playing' 状态，因为不满足瞬间转换条件
// => 'playing'

// 当发送“AWARD_POINTS”时，会发生自我转换到“PLAYING”。
// 由于满足“didPlayerWin”条件，因此会进行到“win”的瞬间转换。
gameService.send({ type: 'AWARD_POINTS' });
// => 'win'
```

#### 无事件 vs. 通配符转换

- [通配符转换](https://lecepin.github.io/xstate-docs-cn/zh/guides/transitions.html#wildcard-descriptors) 在进入状态节点时不被检查。 无事件转换是，在做任何其他事情之前（甚至在进入动作的守卫判断之前）的转换。
- 无事件转换的重新判断，由任何可操作的事件触发。 通配符转换的重新判断，仅由与显式事件描述符不匹配的事件触发。

> 注意
>
> 如果误用无事件转换，则有可能创建无限循环。 无事件转换应该使用 `target`、`cond` + `target`、`cond` + `actions` 或 `cond` + `target` + `actions` 来定义。 目标（如果已声明）应与当前状态节点不同。 没有 `target` 和 `cond` 的无事件转换将导致无限循环。 如果 `cond` 守卫不断返回 `true`，则带有 `cond` 和 `actions` 的转换可能会陷入无限循环。

> 提示
>
> 当检查无事件转换时，它们的守卫会被重复判断，直到它们都返回 false，或者验证了具有目标的转换。 在此过程中，每当某个守卫判断为 `true` 时，其关联的操作将被执行一次。 因此，在单个微任务期间，可能会多次执行一些没有目标的转换。这与普通转换形成对比，在普通转换中，最多只能进行一个转换。

#### 禁止转换

在 XState 中，“禁止”转换是一种指定不应随指定事件发生状态转换的转换。 也就是说，在禁止转换上不应发生任何事情，并且该事件不应由父状态节点处理。

通过将 `target` 明确指定为 `undefined` 来进行禁止转换。 这与将其指定为没有操作的内部转换相同：

```js
on: {
  // 禁止转换
  LOG: undefined,
  // same thing as...
  LOG: {
    actions: []
  }
}
```

例如，我们模拟所有事件都可以记录 log 数据，只在 userInfoPage 下不可以：

```js
const formMachine = createMachine({
  id: 'form',
  initial: 'firstPage',
  states: {
    firstPage: {
      /* ... */
    },
    secondPage: {
      /* ... */
    },
    userInfoPage: {
      on: {
        // 明确禁止 LOG 事件执行任何操作或将任何转换，转换为任何其他状态
        LOG: undefined
      }
    }
  },
  on: {
    LOG: {
      actions: 'logTelemetry'
    }
  }
});
```

> 提示
>
> 请注意，在分层嵌套状态链中定义具有相同事件名称的多个转换时，将只采用最内部的转换。 在上面的例子中，这就是为什么一旦状态机到达 `userInfoPage` 状态，父 `LOG` 事件中定义的 `logTelemetry` 动作就不会执行。

#### 多个目标

基于单个事件的转换可以有多个目标状态节点。 这是不常见的，只有在状态节点合法时才有效； 例如，在复合状态节点中，转换到两个兄弟状态节点是非法的，因为（非并行）状态机在任何给定时间只能处于一种状态。

多个目标在 `target: [...]` 中被指定为一个数组，其中数组中的每个目标都是一个状态节点的相对键或 ID，就像单个目标一样。

```js
const settingsMachine = createMachine({
  id: 'settings',
  type: 'parallel',
  states: {
    mode: {
      initial: 'active',
      states: {
        inactive: {},
        pending: {},
        active: {}
      }
    },
    status: {
      initial: 'enabled',
      states: {
        disabled: {},
        enabled: {}
      }
    }
  },
  on: {
    // 多目标
    DEACTIVATE: {
      target: ['.mode.inactive', '.status.disabled']
    }
  }
});
```

#### 通配描述符 4.7+

使用通配符事件描述符 (`"*"`) 指定的转换由任何事件激活。 这意味着 *任何事件* 都将匹配具有 `on: { "*": ... }` 的转换，并且如果守卫通过，则将采用该转换。

除非在数组中指定转换，否则将始终选择显式事件描述符而不是通配符事件描述符。 在这种情况下，转换的顺序决定了选择哪个转换。

```js
// 对于 SOME_EVENT，将显式转换到“here”
on: {
  "*": "elsewhere",
  "SOME_EVENT": "here"
}

// 对于 SOME_EVENT，将采用通配符转换为“elsewhere”
on: [
  { event: "*", target: "elsewhere" },
  { event: "SOME_EVENT", target: "here" },
]
```

> 提示
>
> 通配符描述符的行为方式与 [瞬间转换](https://lecepin.github.io/xstate-docs-cn/zh/guides/transitions.html#transient-transitions)（具有空事件描述符）*不同*。 每当状态处于活动状态时都会立即进行瞬态转换，而通配符转换仍然需要将某些事件发送到其状态才能触发。

**示例:**

```js
const quietMachine = createMachine({
  id: 'quiet',
  initial: 'idle',
  states: {
    idle: {
      on: {
        WHISPER: undefined,
        // 在除 WHISPER 之外的任何事件中，转换到 'disturbed' 状态
        '*': 'disturbed'
      }
    },
    disturbed: {}
  }
});

quietMachine.transition(quietMachine.initialState, { type: 'WHISPER' });
// => State { value: 'idle' }

quietMachine.transition(quietMachine.initialState, { type: 'SOME_EVENT' });
// => State { value: 'disturbed' }
```

#### FAQ

**如何在转换中执行 if/else 逻辑？**

有时，你会想说：

- 如果 *something* 是真的，就进入这个状态
- 如果 *something else* 为真，则转到此状态
- 否则，进入这个状态

你可以使用 [守卫转换](https://lecepin.github.io/xstate-docs-cn/zh/guides/guards.html#guarded-transitions) 来实现这一点

**我如何转换到 *任何* 状态？**

你可以通过为该状态提供自定义 ID 并使用 `target: '#customId'` 来转换到 *任何* 状态。 你可以在此处阅读有关 [自定义 ID 的完整文档](https://lecepin.github.io/xstate-docs-cn/zh/guides/ids.html#custom-ids)。

这允许你从子状态转换到父级的兄弟状态，例如在本例中的 `CANCEL` 和 `done` 事件中

### 分层状态节点 Hierarchical State Node

在状态图中，状态可以嵌套 *在其他状态中* 。 这些嵌套状态称为 **复合状态**。 要了解更多信息，请阅读[状态图简介中的复合状态部分](https://lecepin.github.io/xstate-docs-cn/zh/guides/introduction-to-state-machines-and-statecharts/#compound-states)。

#### API

以下示例是具有嵌套状态的交通灯状态机：

```js
const pedestrianStates = {
  initial: 'walk',
  states: {
    walk: {
      on: {
        PED_COUNTDOWN: { target: 'wait' }
      }
    },
    wait: {
      on: {
        PED_COUNTDOWN: { target: 'stop' }
      }
    },
    stop: {},
    blinking: {}
  }
};

const lightMachine = createMachine({
  key: 'light',
  initial: 'green',
  states: {
    green: {
      on: {
        TIMER: { target: 'yellow' }
      }
    },
    yellow: {
      on: {
        TIMER: { target: 'red' }
      }
    },
    red: {
      on: {
        TIMER: { target: 'green' }
      },
      ...pedestrianStates
    }
  },
  on: {
    POWER_OUTAGE: { target: '.red.blinking' },
    POWER_RESTORED: { target: '.red' }
  }
});
```

![image-20230309161819652](image-20230309161819652.png)

`'green'` 和 `'yellow'` 状态是 **简单的状态** ——它们没有子状态。 相比之下，`'red'` 状态是复合状态，因为它由 **子状态**（`pedestrianStates`）组成。

#### 初始状态

当进入复合状态时，它的初始状态也立即进入。 在以下交通灯状态机示例中：

- `'red'` 状态已进入
- 由于 `'red'` 的初始状态为 `'walk'`，因此最终进入 `{ red: 'walk' }` 状态。

```js
console.log(lightMachine.transition('yellow', { type: 'TIMER' }).value);
// => {
//   red: 'walk'
// }
```

#### 事件

当前状态不处理 `event` 时，该 `event` 将传播到其要处理的父状态。 在以下交通灯状态机示例中：

- `{ red: 'stop' }` 状态 *不* 处理`'TIMER'` 事件
- `'TIMER'` 事件被发送到处理该事件的 `'red'` 父状态。

```js
console.log(lightMachine.transition({ red: 'stop' }, { type: 'TIMER' }).value);
// => 'green'
```

如果状态或其任何祖先（父）状态均未处理事件，则不会发生转换。 在 `strict` 模式下（在 [状态机配置](https://lecepin.github.io/xstate-docs-cn/zh/guides/machines.html#configuration) 中指定），这将引发错误。

```js
console.log(lightMachine.transition('green', { type: 'UNKNOWN' }).value);
// => 'green'
```

### 并行状态节点 Parallel State Node

在状态图中，你可以将状态声明为 **并行状态**。 这意味着它的所有子状态将同时运行。 要了解更多信息，请参阅 中的部分。

#### API

通过设置 `type: 'parallel'` 在状态机和/或任何嵌套复合状态上指定并行状态节点。

例如，下面的状态机允许 `upload` 和 `download` 复合状态同时处于活动状态。 想象一下，这代表一个可以同时下载和上传文件的应用程序：

```js
const fileMachine = createMachine({
  id: 'file',
  type: 'parallel',
  states: {
    upload: {
      initial: 'idle',
      states: {
        idle: {
          on: {
            INIT_UPLOAD: { target: 'pending' }
          }
        },
        pending: {
          on: {
            UPLOAD_COMPLETE: { target: 'success' }
          }
        },
        success: {}
      }
    },
    download: {
      initial: 'idle',
      states: {
        idle: {
          on: {
            INIT_DOWNLOAD: { target: 'pending' }
          }
        },
        pending: {
          on: {
            DOWNLOAD_COMPLETE: { target: 'success' }
          }
        },
        success: {}
      }
    }
  }
});

console.log(fileMachine.initialState.value);
// => {
//   upload: 'idle',
//   download: 'idle'
// }
```

### 最终状态

在状态图中，你可以将状态声明为 **最终状态**。 最终状态表示其父状态为“完成”。 要了解更多信息，请阅读我们对 [状态图的介绍中的最后状态部分](https://lecepin.github.io/xstate-docs-cn/zh/guides/introduction-to-state-machines-and-statecharts/#final-state)

#### API

要指示状态节点是最终节点，请将其 `type` 属性设置为 `'final'`：

```js
const lightMachine = createMachine({
  id: 'light',
  initial: 'green',
  states: {
    green: {
      on: {
        TIMER: { target: 'yellow' }
      }
    },
    yellow: {
      on: {
        TIMER: { target: 'red' }
      }
    },
    red: {
      type: 'parallel',
      states: {
        crosswalkNorth: {
          initial: 'walk',
          states: {
            walk: {
              on: {
                PED_WAIT: { target: 'wait' }
              }
            },
            wait: {
              on: {
                PED_STOP: { target: 'stop' }
              }
            },
            stop: {
              // 'stop' 是 crosswalkNorth' 的最终状态节点
              type: 'final'
            }
          },
          onDone: {
            actions: 'stopCrosswalkNorth'
          }
        },
        crosswalkEast: {
          initial: 'walk',
          states: {
            walk: {
              on: {
                PED_WAIT: { target: 'wait' }
              }
            },
            wait: {
              on: {
                PED_STOP: { target: 'stop' }
              }
            },
            stop: {
              type: 'final'
            }
          },
          onDone: {
            // 'stop' 是 'crosswalkEast' 的最终状态节点
            actions: 'stopCrosswalkEast'
          }
        }
      },
      onDone: 'green'
    }
  }
});
```

在复合状态中，到达最终子状态节点（使用 `{ type: 'final' }`）将在内部引发该复合状态节点的 `done(...)` 事件（例如，`"done.state. light.crosswalkEast"`)。 使用 `onDone` 相当于为此事件定义一个转换。

#### 并行状态

当并行状态节点中的每个子状态节点都 *完成* 时，父并行状态节点也 *完成*。 当到达每个子复合节点中的每个最终状态节点时，将为并行状态节点引发 `done(...)` 事件。

这在建模并行任务时非常有用。 例如，下面有一个购物机，其中 `user` 和 `items` 表示 `cart` 状态的两个并行任务：

```js
const shoppingMachine = createMachine({
  id: 'shopping',
  initial: 'cart',
  states: {
    cart: {
      type: 'parallel',
      states: {
        user: {
          initial: 'pending',
          states: {
            pending: {
              entry: 'getUser',
              on: {
                RESOLVE_USER: { target: 'success' },
                REJECT_USER: { target: 'failure' }
              }
            },
            success: { type: 'final' },
            failure: {}
          }
        },
        items: {
          initial: 'pending',
          states: {
            pending: {
              entry: 'getItems',
              on: {
                RESOLVE_ITEMS: { target: 'success' },
                REJECT_ITEMS: { target: 'failure' }
              }
            },
            success: { type: 'final' },
            failure: {}
          }
        }
      },
      onDone: 'confirm'
    },
    confirm: {
      // ...
    }
  }
});
```

`onDone` 转换只会在 `'cart'` 的所有子状态（例如，`'user'` 和 `'items'`）都处于它们的最终状态时发生。 在购物机的情况下，一旦到达`'shopping.cart.user.success'`和`'shopping.cart.items.success'`状态节点，状态机将从`'cart'`过渡到 `'confirm'` 状态。

> 注意
>
> 不能在状态机的根节点上定义 `onDone` 转换。 这是因为 `onDone` 是对 `'done.state.*'` 事件的转换，当状态机达到最终状态时，它不能再接受任何事件。

#### 笔记

- 最终状态节点仅指示其直接父节点已 *完成*。 它不会影响任何更高父节点的 *完成* 状态，除非在其所有子复合状态节点 *完成* 时。
- 到达最终子状态的并行状态在其所有同级完成之前不会停止接收事件。 最后的子状态仍然可以通过事件退出。
- 最终状态节点不能有任何子节点。 它们是原子状态节点。
- 你可以在最终状态节点上指定 `entry` 和 `exit` 动作。

### 作用 Effects

在状态图中，“副作用”可以分为两类：

**“即发即弃”副作用**，执行同步副作用，不将事件发送回状态图，或将 *事件同步发送* 回状态图：

- [动作（Actions）](https://lecepin.github.io/xstate-docs-cn/zh/guides/actions.html) - 单一的、分散的作用
- [活动（Activities）](https://lecepin.github.io/xstate-docs-cn/zh/guides/activities.html) - 退出它们开始所处的状态时处理的连续作用

**调用作用**，它执行一个可以 *异步* 发送和接收事件的副作用：

- [调用 Promises](https://lecepin.github.io/xstate-docs-cn/zh/guides/communication.html#invoking-promises) - 随着时间的推移，可能会 `resolve` 或 `reject` 一次的单个分散副作用，这些作用结果，通过事件发送到父状态机
- [调用 Callbacks](https://lecepin.github.io/xstate-docs-cn/zh/guides/communication.html#invoking-callbacks) - 随着时间的推移可能会发送多个事件的持续副作用，以及监听直接发送给它的事件，到/从 父状态机
- [调用 Observables](https://lecepin.github.io/xstate-docs-cn/zh/guides/communication.html#invoking-observables) - 随着时间的推移，可能会发送由来自观察流的消息触发的多个事件的持续副作用
- [调用 Machines](https://lecepin.github.io/xstate-docs-cn/zh/guides/communication.html#invoking-machines) - 由`Machine` 实例表示的连续副作用，可以发送/接收事件，也可以在达到 [最终状态](https://lecepin.github.io/xstate-docs-cn/zh/guides/final.html) 时通知父状态机

### 动作 Actions

动作，是即发即弃的 [作用](https://lecepin.github.io/xstate-docs-cn/zh/guides/effects.html)。 它们可以通过三种方式声明：

- `entry` 动作，进入状态时执行
- `exit` 动作，退出状态时执行
- 执行转换时，执行转换的动作

要了解更多信息，请阅读 [状态图简介中的动作](https://lecepin.github.io/xstate-docs-cn/zh/guides/introduction-to-state-machines-and-statecharts/#actions)

#### API

可以像这样添加动作

```js
const triggerMachine = createMachine(
  {
    id: 'trigger',
    initial: 'inactive',
    states: {
      inactive: {
        on: {
          TRIGGER: {
            target: 'active',
            // 转换 actions
            actions: ['activate', 'sendTelemetry']
          }
        }
      },
      active: {
        // 进入 actions
        entry: ['notifyActive', 'sendTelemetry'],
        // 退出 actions
        exit: ['notifyInactive', 'sendTelemetry'],
        on: {
          STOP: { target: 'inactive' }
        }
      }
    }
  },
  {
    actions: {
      // action 实现
      activate: (context, event) => {
        console.log('activating...');
      },
      notifyActive: (context, event) => {
        console.log('active!');
      },
      notifyInactive: (context, event) => {
        console.log('inactive!');
      },
      sendTelemetry: (context, event) => {
        console.log('time:', Date.now());
      }
    }
  }
);
```

什么时候应该使用 转换 VS entry/exit 动作？

这取决于！ 它们的做的事不同：

- entry/exit 操作，意味着“在进入/退出此状态的任何转换上 **执行此 动作**”。 当 动作 只依赖于它所在的状态节点，而不依赖于上一个/下一个状态节点 或 事件时，使用进入/退出 动作

  ```js
  // ...
  {
    idle: {
      on: {
        LOAD: 'loading'
      }
    },
    loading: {
      // 每当进入“loading”状态时执行此 动作
      entry: 'fetchData'
    }
  }
  // ...
  ```

- 转换 动作 意味着“仅在此转换上 **执行此 动作**”。 当 动作 依赖于事件和它当前所处的状态节点时，使用转换 动作。

  ```js
  // ...
  {
    idle: {
      on: {
        LOAD: {
          target: 'loading',
          // 此 动作 仅在此转换时执行
          actions: 'fetchData'
      }
    },
    loading: {
      // ...
    }
  }
  // ...
  ```

> 提示
>
> 可以通过直接在状态机配置中指定 动作 函数来快速原型化 动作 实现：
>
> ```js
> // ...
> TRIGGER: {
>   target: 'active',
>   actions: (context, event) => { console.log('activating...'); }
> }
> // ...
> ```
>
> 在状态机选项的 `actions` 属性中重构内联 动作 实现，可以更容易地调试、序列化、测试和准确地可视化 动作。

#### 声明动作

从 `machine.transition(...)` 返回的 `State` 实例有一个 `.actions` 属性，它是一个供 解释（interpret） 执行的 动作 对象数组：

```js
const activeState = triggerMachine.transition('inactive', { type: 'TRIGGER' });

console.log(activeState.actions);
// [
//   { type: 'activate', exec: ... },
//   { type: 'sendTelemetry', exec: ... },
//   { type: 'notifyActive', exec: ... },
//   { type: 'sendTelemetry', exec: ... }
// ]
```

每个 动作 对象都有两个属性（以及其他可以指定的属性）：

- `type` - 动作 类型
- `exec` - 动作 执行函数

`exec` 函数有 3 个参数：

| 参数         | 类型         | 描述                                   |
| ------------ | ------------ | -------------------------------------- |
| `context`    | TContext     | 当前状态机的上下文                     |
| `event`      | event object | 导致转换的事件                         |
| `actionMeta` | meta object  | 包含有关 动作 的元数据的对象（见下文） |

`actionMeta` 对象包括以下属性：

| 参数     | 类型          | 描述                       |
| -------- | ------------- | -------------------------- |
| `action` | action object | 原始 动作 对象             |
| `state`  | State         | 转换后的已解析的状态机状态 |

解释（interpret）将调用带有 `currentState.context`、`event` 和状态机转换到的 `state` 的 `exec` 函数。 你可以自定义此 动作。 阅读 [执行 动作](https://lecepin.github.io/xstate-docs-cn/zh/guides/interpretation.html#executing-actions) 了解更多详情。

#### 动作顺序

在执行状态图时，动作的顺序不一定重要（也就是说，它们不应该相互依赖）。 但是，`state.actions` 数组中的操作顺序是：

1. `exit` 动作 - 退出状态节点的所有退出 动作，从原子状态节点开始
2. 转换 `actions` - 在所选转换上定义的所有 动作
3. `entry` 动作 - 进入状态节点的所有进入 动作，从父状态开始

> 注意
>
> 在 XState 4.x 版中，`assign` 动作 具有优先权，并且在任何其他 动作 之前执行。 此行为将在第 5 版中修复，因为将按顺序调用 `assign` 操作。

> 警告
>
> 此处记录的所有 动作 创建者都返回 **动作 对象**； 它是一个纯函数，它只返回一个 动作 对象，并 *不是* 命令式的发送一个事件。 不要命令式的调用 动作 创建者； 因为 他们什么都不会做！
>
> ```js
> // 🚫 不要这样做！
> entry: () => {
>   // 🚫 这将什么也不做； send() 不是命令式函数！
>   send({ type: 'SOME_EVENT' });
> };
> 
> console.log(send({ type: 'SOME_EVENT' }));
> // => { type: 'xstate.send', event: { type: 'SOME_EVENT' } }
> 
> // ✅ 这样替换
> entry: send({ type: 'SOME_EVENT' });
> ```

#### 发送动作（send action）

`send(event)` 动作 创建者创建了一个特殊的“发送” 动作 对象，它告诉服务（即，[解释（interpret） 状态机](https://lecepin.github.io/xstate-docs-cn/zh/guides/interpretation.html)）将该事件发送给它自己。 它在外部事件队列中，将一个事件排入正在运行的服务中，这意味着该事件将在 解释（interpret） 的下一步“步骤”上发送。

| 参数       | 类型                                       | 描述                                   |
| ---------- | ------------------------------------------ | -------------------------------------- |
| `event`    | string or event object or event expression | 发送到指定`options.to`（或self）的事件 |
| `options?` | send options (见下文)                      | 发送事件的选项。                       |

send `options` 参数是一个包含以下内容的对象：

| 参数     | 类型   | 描述                                                   |
| -------- | ------ | ------------------------------------------------------ |
| `id?`    | string | send ID (用于取消)                                     |
| `to?`    | string | 事件的目标（默认为self）                               |
| `delay?` | number | 发送事件前的超时时间（毫秒），如果在超时前没有取消事件 |

> 注意
>
> `send(...)` 函数是一个 **动作 创建者**； 它是一个纯函数，它只返回一个 动作 对象，并 *不会* 命令式地发送一个事件。

```js
import { createMachine, send } from 'xstate';

const lazyStubbornMachine = createMachine({
  id: 'stubborn',
  initial: 'inactive',
  states: {
    inactive: {
      on: {
        TOGGLE: {
          target: 'active',
          // 再次向服务发送 TOGGLE 事件
          actions: send('TOGGLE')
        }
      }
    },
    active: {
      on: {
        TOGGLE: { target: 'inactive' }
      }
    }
  }
});

const nextState = lazyStubbornMachine.transition('inactive', {
  type: 'TOGGLE'
});

nextState.value;
// => 'active'
nextState.actions;
// => [{ type: 'xstate.send', event: { type: 'TOGGLE' }}]

// 该服务将继续向自己发送 { type: 'TOGGLE' } 事件。
```

传递给 `send(event)` 的 `event` 参数可以是：

- 一个字符串事件，例如 `send('TOGGLE')`
- 一个对象事件，例如 `send({ type: 'TOGGLE', payload: ... })`
- 一个事件表达式，它是一个函数，它接收触发 `send()` 动作 的当前 `context` 和 `event`，并返回一个事件对象：

```js
import { send } from 'xstate';

// 人为的例子 - 从 `context` 读取并发送动态创建的事件
const sendName = send((context, event) => ({
  type: 'NAME',
  name: context.user.name
}));

const machine = createMachine({
  // ...
  on: {
    TOGGLE: {
      actions: sendName
    }
  }
  //...
});
```

##### 发送目标

从 `send(...)` 动作 创建者发送的事件，可以表示它应该发送到特定目标，例如 [调用 服务](https://lecepin.github.io/xstate-docs-cn/zh/guides/communication.html) 或 [创建 演员](https://lecepin.github.io/xstate-docs-cn/zh/guides/actors.html)。 这是通过在 `send(...)` 操作中指定 `{ to: ... }` 属性来完成的：

```js
// ...
invoke: {
  id: 'some-service-id',
  src: 'someService',
  // ...
},
// ...
// 表示向调用的服务发送 { type: 'SOME_EVENT' }
actions: send({ type: 'SOME_EVENT' }, { to: 'some-service-id' })
```

`to` 属性中的 target 也可以是一个 **target 表达式**，它是一个函数，它接受当前触发动作的 `context` 和 `event`，并返回一个字符串 target 或一个 [演员](https://lecepin.github.io/xstate-docs-cn/zh/guides/actors.html#spawning-actors):

```js
entry: assign({
  someActor: () => {
    return spawn(someMachine, 'some-actor-name');
  }
}),
  // ...

  // 发送 { type: 'SOME_EVENT' } 到 演员 引用
  {
    actions: send(
      { type: 'SOME_EVENT' },
      {
        to: (context) => context.someActor
      }
    )
  };
```

> 注意
>
> 同样，`send(...)` 函数是一个 动作 创建者，**不会命令式发送事件。** 相反，它返回一个 动作 对象，描述事件将发送到的位置：
>
> ```js
> console.log(send({ type: 'SOME_EVENT' }, { to: 'child' }));
> // logs:
> // {
> //   type: 'xstate.send',
> //   to: 'child',
> //   event: {
> //     type: 'SOME_EVENT'
> //   }
> // }
> ```

要从子状态机发送到父状态机，请使用 `sendParent(event)`（采用与 `send(...)` 相同的参数）。

#### 升高动作（raise action）

`raise()` 动作 创建者在内部事件队列中，将一个事件排入状态图。 这意味着事件会在 解释（interpret） 的当前“步骤”上立即发送。

| 参数    | 类型                   | 描述         |
| ------- | ---------------------- | ------------ |
| `event` | string or event object | 要提升的事件 |

```js
import { createMachine, actions } from 'xstate';
const { raise } = actions;

const raiseActionDemo = createMachine({
  id: 'raisedmo',
  initial: 'entry',
  states: {
    entry: {
      on: {
        STEP: {
          target: 'middle'
        },
        RAISE: {
          target: 'middle',
          // 立即为“middle”调用 NEXT 事件
          actions: raise('NEXT')
        }
      }
    },
    middle: {
      on: {
        NEXT: { target: 'last' }
      }
    },
    last: {
      on: {
        RESET: { target: 'entry' }
      }
    }
  }
});
```

单击 [visualizer ](https://stately.ai/viz?gist=fd763ff2c161b172f719891e2544d428)中的“STEP”和“RAISE”事件以查看差异。

#### 响应动作 （respond action） 4.7+

`respond()` 动作 创建者创建一个 [`send()` 动作](https://lecepin.github.io/xstate-docs-cn/zh/guides/actions.html#send-action)，该 动作 被发送到，触发响应的事件的服务。

这在内部使用 [SCXML 事件](https://lecepin.github.io/xstate-docs-cn/zh/guides/scxml.html#events) ，从事件中获取 `origin`，并将 `send()` 动作 的 `to` 设置为 `origin`。

| 参数       | 类型                                     | 描述                       |
| ---------- | ---------------------------------------- | -------------------------- |
| `event`    | string, event object, or send expression | 发送回发件人的事件         |
| `options?` | send options object                      | 传递到 `send()` 事件的选项 |

##### 使用响应 action 的示例

这演示了一些父服务（`authClientMachine`）向调用的 `authServerMachine` 发送一个 `'CODE'` 事件，并且 `authServerMachine` 响应一个 `'TOKEN'` 事件。

```js
const authServerMachine = createMachine({
  initial: 'waitingForCode',
  states: {
    waitingForCode: {
      on: {
        CODE: {
          actions: respond({ type: 'TOKEN' }, { delay: 10 })
        }
      }
    }
  }
});

const authClientMachine = createMachine({
  initial: 'idle',
  states: {
    idle: {
      on: {
        AUTH: { target: 'authorizing' }
      }
    },
    authorizing: {
      invoke: {
        id: 'auth-server',
        src: authServerMachine
      },
      entry: send('CODE', { to: 'auth-server' }),
      on: {
        TOKEN: { target: 'authorized' }
      }
    },
    authorized: {
      type: 'final'
    }
  }
});
```

详情请参阅 [📖 发送响应](https://lecepin.github.io/xstate-docs-cn/zh/guides/actors.html#sending-responses)。



#### 转发动作（forwardTo action） 4.7+

`forwardTo()` 动作 创建者，创建一个 [`send()` 动作](https://lecepin.github.io/xstate-docs-cn/zh/guides/actions.html#send-action)，通过其 ID 将最近的事件转发到指定的服务。

| 参数     | 类型                                    | 描述                           |
| -------- | --------------------------------------- | ------------------------------ |
| `target` | string or function that returns service | 要将最近事件发送到的目标服务。 |

##### 使用 forwardTo 动作 的示例

```js
import { createMachine, forwardTo, interpret } from 'xstate';

function alertService(_, receive) {
  receive((event) => {
    if (event.type === 'ALERT') {
      alert(event.message);
    }
  });
}

const parentMachine = createMachine({
  id: 'parent',
  invoke: {
    id: 'alerter',
    src: () => alertService
  },
  on: {
    ALERT: { actions: forwardTo('alerter') }
  }
});

const parentService = interpret(parentMachine).start();

parentService.send({ type: 'ALERT', message: 'hello world' });
// => alerts "hello world"
```

#### 错误升级动作（escalate action） 4.7+

`escalate()` 动作 创建者，通过将错误发送到父状态机来升级错误。 这是作为状态机识别的特殊错误事件发送的。

| 参数        | 类型 | 描述                             |
| ----------- | ---- | -------------------------------- |
| `errorData` | any  | 要升高（send）到父级的错误数据。 |

#### 使用 escalate 动作 的示例

```js
import { createMachine, actions } from 'xstate';
const { escalate } = actions;

const childMachine = createMachine({
  // ...
  // 这将被发送到调用这个孩子的父状态机
  entry: escalate({ message: 'This is some error' })
});

const parentMachine = createMachine({
  // ...
  invoke: {
    src: childMachine,
    onError: {
      actions: (context, event) => {
        console.log(event.data);
        //  {
        //    type: ...,
        //    data: {
        //      message: 'This is some error'
        //    }
        //  }
      }
    }
  }
});
```

#### 日志动作（log action）

`log()` 动作 创建器是一种记录与当前状态 `context` 和/或 `event` 相关的任何内容的声明方式。 它需要两个可选参数：

| 参数     | 类型               | 描述                                                         |
| -------- | ------------------ | ------------------------------------------------------------ |
| `expr?`  | string or function | 一个简单的字符串或一个函数，它以 `context` 和 `event` 作为参数并返回一个要记录的值 |
| `label?` | string             | 用于标记已记录消息的字符串                                   |

```js
import { createMachine, actions } from 'xstate';
const { log } = actions;

const loggingMachine = createMachine({
  id: 'logging',
  context: { count: 42 },
  initial: 'start',
  states: {
    start: {
      entry: log('started!'),
      on: {
        FINISH: {
          target: 'end',
          actions: log(
            (context, event) => `count: ${context.count}, event: ${event.type}`,
            'Finish label'
          )
        }
      }
    },
    end: {}
  }
});

const endState = loggingMachine.transition('start', 'FINISH');

endState.actions;
// [
//   {
//     type: 'xstate.log',
//     label: 'Finish label',
//     expr: (context, event) => ...
//   }
// ]

// interpreter 将根据当前状态上下文和事件记录 Action 的表达式。
```

没有任何参数，`log()` 是一个 动作，它记录一个具有 `context` 和 `event` 属性的对象，分别包含当前上下文和触发事件。

#### 选择动作（choose action）

`choose()` 动作 创建者创建一个 动作，该 动作 指定应根据某些条件执行哪些 动作。

| 参数    | 类型  | 描述                                                         |
| ------- | ----- | ------------------------------------------------------------ |
| `conds` | array | 当给定的 `cond` 为真时，包含要执行的 `actions` 的对象数组（见下文） |

**返回:**

一个特殊的 `"xstate.choose"` 动作 对象，它在内部进行判断以有条件地确定应该执行哪些动作对象。

`cond` 中的每个“条件动作”对象都具有以下属性：

- `actions` - 要执行的 动作 对象
- `cond?` - 执行这些 `actions` 的条件

> 注意
>
> 不要使用 `choose()` 动作 创建器来执行 动作，否则这些 动作 可能表示为通过 `entry`、`exit` 或 `actions` 在某些 状态/转换 中执行的非条件 动作。

```js
import { actions } from 'xstate';

const { choose, log } = actions;

const maybeDoThese = choose([
  {
    cond: 'cond1',
    actions: [
      // 当“cond1”为真时
      log('cond1 chosen!')
    ]
  },
  {
    cond: 'cond2',
    actions: [
      // 当“cond1”为假且“cond2”为真时
      log((context, event) => {
        /* ... */
      }),
      log('another action')
    ]
  },
  {
    cond: (context, event) => {
      // 一些条件
      return false;
    },
    actions: [
      // 当“cond1”和“cond2”为假并且内联`cond`为真时
      (context, event) => {
        // 一些其他 action
      }
    ]
  },
  {
    actions: [
      log('fall-through action')
      // 当“cond1”、“cond2”和“cond3”为假时
    ]
  }
]);
```

这类似于 SCXML `<if>`、`<elseif>` 和 `<else>` 元素： [www.w3.org/TR/scxml/#if](https://www.w3.org/TR/scxml/#if)

#### 纯动作（pure action）

`pure()` 动作 创建器是一个纯函数（因此得名），它根据触发 动作 的当前状态“上下文”和“事件”返回要执行的 动作 对象。 这允许你动态定义应执行哪些 动作

| 参数         | 类型     | 描述                                                         |
| ------------ | -------- | ------------------------------------------------------------ |
| `getActions` | function | 根据给定的 `context` 和 `event` 返回要执行的动作对象的函数（见下文） |

**返回:**

一个特殊的 `"xstate.pure"` 动作 对象，它将在内部判断 `get` 属性以确定应该执行的 动作 对象。

`getActions(context, event)` 参数:

| 参数      | 类型         | 描述                 |
| --------- | ------------ | -------------------- |
| `context` | object       | 当前状态的 `context` |
| `event`   | event object | 触发 动作 的事件对象 |

**返回:**

单个 动作 对象、一组 动作 对象或不代表任何 动作 对象的 `undefined`。

```js
import { createMachine, actions } from 'xstate';

const { pure } = actions;

// 动态地向每个调用的示例 actor 发送一个事件
const sendToAllSampleActors = pure((context, event) => {
  return context.sampleActors.map((sampleActor) => {
    return send('SOME_EVENT', { to: sampleActor });
  });
});
// => {
//   type: ActionTypes.Pure,
//   get: () => ... // 计算为 send() action 数组
// }

const machine = createMachine({
  // ...
  states: {
    active: {
      entry: sendToAllSampleActors
    }
  }
});
```

#### 自转换动作

自转换 是当状态转换到自身时，它 可能 退出然后重新进入自身。 自转换可以是 内部 或 外部 转换：

- 内部转换将`不`退出并重新进入自身，因此状态节点的“进入”和“退出”动作将不会再次执行。
  - 内部转换用 `{ internal: true }` 表示，或者将 `target` 保留为 `undefined`。
  - 将执行在转换的 `actions` 属性上定义的 动作。
- 外部转换`将`退出并重新进入自身，因此状态节点的`entry`和`exit` action 将再次执行。
  - 默认情况下，所有转换都是外部的。 为了明确起见，你可以使用 `{ internal: false }` 来指示它们。
  - 将执行在转换的 `actions` 属性上定义的 动作。

例如，这个计数器状态机，有一个带有内部和外部转换的 `'counting'` 状态：

```js
onst counterMachine = createMachine({
  id: 'counter',
  initial: 'counting',
  states: {
    counting: {
      entry: 'enterCounting',
      exit: 'exitCounting',
      on: {
        // 自转换
        INC: { actions: 'increment' }, // 内部（隐式）
        DEC: { target: 'counting', actions: 'decrement' }, // 外部
        DO_NOTHING: { internal: true, actions: 'logNothing' } // 内部（隐式）
      }
    }
  }
});

// 外部转换（退出+ 转换action +进入）
const stateA = counterMachine.transition('counting', { type: 'DEC' });
stateA.actions;
// ['exitCounting', 'decrement', 'enterCounting']

// 内部转换（转换动作）
const stateB = counterMachine.transition('counting', { type: 'DO_NOTHING' });
stateB.actions;
// ['logNothing']

const stateC = counterMachine.transition('counting', { type: 'INC' });
stateB.actions;
// ['increment']
```

### 守卫（Guarded）转换

很多时候，你会希望状态之间的转换仅在满足状态（有限或扩展）或事件的某些条件时发生。 例如，假设你正在为搜索表单创建一台状态机，并且你只希望在以下情况下允许搜索：

- 允许用户搜索（本例中为`.canSearch`）
- 搜索事件`query` 不为空。

这是“守卫转换”的一个很好的用例，这是一种仅在某些条件（`cond`）通过时才会发生的转换。 带有条件的转换称为**守卫转换**。

#### 守卫 (条件函数)

在转换的 `.cond` 属性上指定的 **条件函数**（也称为 **守卫**），作为具有 `{ type: '...' }` 属性的字符串或条件对象 , 并接受 3 个参数：

| 参数       | 类型   | 描述                                                         |
| ---------- | ------ | ------------------------------------------------------------ |
| `context`  | object | [状态机 context](https://lecepin.github.io/xstate-docs-cn/zh/guides/context.html) |
| `event`    | object | 触发条件的事件                                               |
| `condMeta` | object | 元数据（见下文）                                             |

`condMeta` 对象包括以下属性：

- `cond` - 原始条件对象
- `state` - 转换前的当前状态机状态
- `_event` - SCXML 事件

**返回**

`true` 或 `false`，决定是否允许进行转换。

```js
const searchValid = (context, event) => {
  return context.canSearch && event.query && event.query.length > 0;
};

const searchMachine = createMachine(
  {
    id: 'search',
    initial: 'idle',
    context: {
      canSearch: true
    },
    states: {
      idle: {
        on: {
          SEARCH: [
            {
              target: 'searching',
              // 仅当守卫 (cond) 判断为真时才过渡到“搜索”
              cond: searchValid // 或 { type: 'searchValid' }
            },
            { target: '.invalid' }
          ]
        },
        initial: 'normal',
        states: {
          normal: {},
          invalid: {}
        }
      },
      searching: {
        entry: 'executeSearch'
        // ...
      },
      searchError: {
        // ...
      }
    }
  },
  {
    guards: {
      searchValid // 可选，如果实现没有改变
    }
  }
);
```

单击 *EVENTS* 选项卡并发送一个类似`{ "type": "SEARCH", "query": "something" }` 的事件，如下所示：

如果 `cond` 守卫返回 `false`，则不会选择转换，并且不会从该状态节点发生转换。 如果子状态中的所有转换都有判断为 `false` 的守卫，并阻止它们被选择，则 `event` 将传播到父状态 并在那里处理。

`context` 的使用示例：

```js
import { interpret } from 'xstate';

const searchService = interpret(searchMachine)
  .onTransition((state) => console.log(state.value))
  .start();

searchService.send({ type: 'SEARCH', query: '' });
// => 'idle'

searchService.send({ type: 'SEARCH', query: 'something' });
// => 'searching'
```

> 提示
>
> 通过直接在状态机配置中指定内联的守卫 `cond` 函数，可以快速构建守卫实现的原型：
>
> ```js
> // ...
> SEARCH: {
>   target: 'searching',
>   cond: (context, event) => context.canSearch && event.query && event.query.length > 0
> }
> // ...
> ```
>
> 在状态机选项的 `guards` 属性中重构内联 守卫，实现可以更容易地调试、序列化、测试和准确地可视化的守卫。

#### 序列化守卫

守卫 可以（并且应该）被序列化为字符串或具有 `{ type: '...' }` 属性的对象。 守卫的实现细节在状态机选项的`guards`属性上指定，其中`key`是守卫`type`（指定为字符串或对象），值是一个接受三个参数的函数：

- `context` - 当前状态机 context
- `event` - 触发（潜在）转换的事件
- `guardMeta` - 一个包含有关守卫和转换的元数据的对象，包括：
  - `cond` - 原始 `cond` 对象
  - `state` - 转换前的，当前状态机 state

重构上面的例子：

```js
const searchMachine = createMachine(
  {
    // ...
    states: {
      idle: {
        on: {
          SEARCH: {
            target: 'searching',
            // 'searchValid' 守卫实现细节在状态机配置中指定
            cond: 'searchValid' // 或 { type: 'searchValid' }
          }
        }
      }
      // ...
    }
  },
  {
    guards: {
      searchValid: (context, event) => {
        return context.canSearch && event.query && event.query.length > 0;
      }
    }
  }
);
```

#### 自定义守卫 4.4+

有时，最好不仅序列化 JSON 中的状态转换，还序列化 守卫 逻辑。 这是将守卫序列化为对象的有用之处，因为对象可能包含相关数据：

```js
const searchMachine = createMachine(
  {
    // ...
    states: {
      idle: {
        on: {
          SEARCH: {
            target: 'searching',
            // 自定义 guard 对象
            cond: {
              type: 'searchValid',
              minQueryLength: 3
            }
          }
        }
      }
      // ...
    }
  },
  {
    guards: {
      searchValid: (context, event, { cond }) => {
        // cond === { type: 'searchValid', minQueryLength: 3 }
        return (
          context.canSearch &&
          event.query &&
          event.query.length > cond.minQueryLength
        );
      }
    }
  }
);
```

#### 多个守卫

如果你想在某些情况下将单个事件转换到不同的状态，你可以提供一组条件转换。 每个转换都将按顺序进行测试，并且将采用第一个 cond 保护判断为 true 的转换。

例如，你可以建模一扇门，它监听 OPEN 事件，如果你是管理员则进入 'opened' 状态，或者如果 alert 为真 则进入 'closed.error' 状态 ，否则进入 'closed.idle' 状态。

```js
import { createMachine, actions, interpret, assign } from 'xstate';

const doorMachine = createMachine(
  {
    id: 'door',
    initial: 'closed',
    context: {
      level: 'user',
      alert: false // 发生入侵时发出警报
    },
    states: {
      closed: {
        initial: 'idle',
        states: {
          idle: {},
          error: {}
        },
        on: {
          SET_ADMIN: {
            actions: assign({ level: 'admin' })
          },
          SET_ALARM: {
            actions: assign({ alert: true })
          },
          OPEN: [
            // 一次测试一个转换。
            // 将进行第一个有效转换。
            { target: 'opened', cond: 'isAdmin' },
            { target: '.error', cond: 'shouldAlert' },
            { target: '.idle' }
          ]
        }
      },
      opened: {
        on: {
          CLOSE: { target: 'closed' }
        }
      }
    }
  },
  {
    guards: {
      isAdmin: (context) => context.level === 'admin',
      shouldAlert: (context) => context.alert === true
    }
  }
);

const doorService = interpret(doorMachine)
  .onTransition((state) => console.log(state.value))
  .start();
// => { closed: 'idle' }

doorService.send({ type: 'OPEN' });
// => { closed: 'idle' }

doorService.send({ type: 'SET_ALARM' });
// => { closed: 'idle' }
// (状态不会改变，但上下文会改变)

doorService.send({ type: 'OPEN' });
// => { closed: 'error' }

doorService.send({ type: 'SET_ADMIN' });
// => { closed: 'error' }
// (状态不会改变，但上下文会改变)

doorService.send({ type: 'OPEN' });
// => 'opened'
// (因为 context.isAdmin === true)
```











