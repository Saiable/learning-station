[TOC]

> 掌握`HTML5/CSS3`核心知识及实战技巧
>
> 掌握`CSS3`中浮动/定位等布局方案
>
> 掌握`CSS3`中的`transition`和`animation`
>
> 掌握基于`flex`弹性盒模型的布局方案
>
> 同行排列的`N`种实现方案及优缺点对比
>
> `CSS3`样式编写中的模块思想及封装处理
>
> 掌握`JS`（包含`ES6+`）、`DOM`操作等核心知识
>
> 掌握`DOM`事件的核心知识及事件委托
>
> 掌握基于`JS+CSS3`动画的实战处理方案
>
> 掌握`Promise/async/await`异步管控方案
>
> 掌握`Ajax/Axios`的核心应用及数据绑定
>
> 基于`JS`管控`video`视频播放的解决方案
>
> 基于单例设计模式/`ESModule`实现模块化编程
>
> 基于`JS`实现页卡切换：两种不同处理思想
>
> 基于`JS`实现多种形态轮播图案例开发
>
> 基于`iscroll`插件实现局部滚动
>
> 基于`JS`实现“鼠标滑动的图片幻灯片”特效
>
> 基于`JS`打造炫酷的侧边栏楼层导航
>
> 人性化交互设计方案：`Loading&`防抖`&`节流
>
> 前端性能优化方案：图片懒加载`&`骨架屏`&Skeleton`



# 英雄联盟官网案例

## 项目模块化开发

- 基于`vue/react/webpack`工程化开发（项目中主流思想）

- 不想用工程化开发的方式，只想自己简单的写法页面，如何实现模块化呢？
  - `HTML`
  
    - 分版块设置结构（就写在一起了）
  
  - `CSS`
  
    - 基于前缀区分模块
  
    - 每个模块单独写在`CSS`文件中，最后不同模块统一导入到入口文件里，并利用`less/sass`的嵌套语法简化前缀书写
  
      - 首页`index.html`中导入`index.less`入口文件，同时通入编译`less`的`js`文件
  
        `index.html`
  
        ```html
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta http-equiv="X-UA-Compatible" content="IE=edge">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>英雄联盟官网</title>
        
            <!-- 导入less -->
            <link res="stylesheet/less" href="./css/index.less"></link>
            <script src="css/less.min.js"></script>
        </head>
        <body>
            
        </body>
        </html>
        ```
  
        `less`浏览器端编译文件下载：https://github.com/less/less.js/releases，下载后在`dist`文件夹
  
        `index.less`
  
        ```less
        // 公用样式
        
        @import './reset.min.css'; //格式化浏览器样式
        @import './common.less'; // 公用样式
        @import './head_box.less'; // 头部模块样式
        ```
  
  - `JS`：不能直接写在不同的`js`文件中然后导入，最后合并的时候仍然会有变量冲突，这里并不存在**模块**的概念
  
    - 基于闭包的方式，实现模块和模块之间变量隔离，防止全局变量污染，也可导出某个模块的方法
  
      ```js
      // 头部
      let headModule = (function () {
          let head_box = null,
              n = 0
      
          const query = function query () {
      
          }
      
          return {
              query
          }
      })()
      
      // 轮播图
      (function() {
          let swiper_box = null,
              n = 1
      
          headModule.query()
      })()
      ```
  
      这种模式就叫做：单例设计模式
  
    - 使用`<script type="module" src="./js/index.js"></script>`，直接让`js`支持`ES6Module`的模块化规范，这个声明只会在新版本浏览器中生效。此时在`index.js`就可以直接使用`import`语法了
  
      `index.html`
  
      ```html
      <!DOCTYPE html>
      <html lang="en">
      <head>
          <meta charset="UTF-8">
          <meta http-equiv="X-UA-Compatible" content="IE=edge">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>英雄联盟官网</title>
      
          <!-- 导入less -->
          <link res="stylesheet/less" href="./css/index.less"></link>
          <script src="css/less.min.js"></script>
      </head>
      <body>
          <!-- 导入js入口文件 -->
          <script type="module" src="./js/index.js"></script>
      </body>
      </html>
      ```
  
      `index.js`
  
      ```js
      import './head_box.js' // 不是webpack环境，后缀要加上
      import './swiper_container.js'
      ```

其他准备：

- `axios、isScroll、qs`在`webpack`中挂载到`window`上并打包成`main.min.js`文件，方便使用

  ```js
  import Iscroll from 'iscroll'
  import axios from 'axios'
  import qs from 'qs'
  
  window.Iscroll = Iscroll
  window.qs = qs
  window.axios = axios
  ```

- 封装`axios`成`http.js`

  ```js
  const http = axios.create({
      // 统一请求前缀
      baseURL: 'http://127.0.0.1:8888',
      // 是否允许跨域时候携带资源凭证
      withCredentials: false,
      // 请求成功的状态码校验规则
      validateStatus: status => {
          return status >= 200 && status < 400;
      },
      // 请求头统一处理「设置请求主体专递给服务器的数据格式」
      headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
      },
      // POST系列请求，请求主体传递信息的格式化
      transformRequest: (data, headers) => {
          if (data !== null && typeof data === "object") {
              const ct = headers['Content-Type'];
              if (ct === "application/x-www-form-urlencoded") {
                  return qs.stringify(data);
              }
          }
          return data;
      }
  });
  
  // 请求拦截器：向服务器发送请求之前
  http.interceptors.request.use(config => {
      // ...
      return config;
  });
  
  // 响应拦截器：获取到响应信息 ~ 自己处理业务逻辑之间
  http.interceptors.response.use(response => {
      // 获取响应主体信息
      return response.data;
  }, reason => {
      // 失败的统一处理「一般就是做相关的提示或者其它操作」
      let response = reason.response;
      if (response) {
          // 服务器有返回值，但是状态码不符合validateStatus校验规则
          switch (response.status) {
              case 400:
                  // ...
                  break;
              case 401:
                  // ...
                  break;
          }
      } else {
          // 服务器没有返回任何的信息
          if (reason && reason.code === "ECONNABORTED") {
              // 超时或者请求中断
          }
          if (!navigator.onLine) {
              // 网络出现故障
          }
      }
      return Promise.reject(reason);
  });
  
  // ES6Module中模块的导出:我想把当前模块中的某个方法，某些东西暴露出去供其他模块调用 export & export default
  export default http;
  ```

  如果当前某个模块在另外一个模块导入过了，以后在其他模块再次导入的话，最后浏览器渲染的时候，也只按导入一次处理

