---
title: '微信小程序概述'
date: 2022-10-15 09:03:02
cover: false
tags:
- 小程序
categories: '小程序'
typora-root-url: 微信小程序概述
---

# 开发准备

注册：[产品定位及功能介绍 | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/introduction/#小程序注册)

最新接口文档：https://github.com/Binaryify/NeteaseCloudMusicApi/releases

# 前置知识

快速入门：

# 项目初始化

文件结构说明

[小程序配置 | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/framework/config.html#全局配置)

# 小程序特点（从0开始写）

项目的配置文件留着，其他都删掉

![image-20221014223704330](image-20221014223704330.png)

一开始会报错

![image-20221014223116106](image-20221014223116106.png)

## app.json

完整内容查看官方文档即可，[小程序配置 | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/framework/config.html)

新建app.json

![image-20221014223736990](image-20221014223736990.png)

报错，因为app.json不能为空，需要添加内容，

小程序根目录下的 `app.json` 文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。

![image-20221014223808736](image-20221014223808736.png)

必填的两个字段是

- pages，页面路径列表（必填）

- sitemapLocation：

  - 指明 [sitemap.json](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/sitemap.html) 的位置；
  - 默认为 'sitemap.json' 即在 app.json 同级目录下名字的 `sitemap.json` 文件，可以不填了

  

### 创建页面

增加一个pages字段，保存后微信开发者工具会自动创建对应的4个文件，显示的页面在这里读取

```json
{
  "pages": [
    "pages/index/index",
    "pages/logs/index"
  ]
}
```

### 设置窗口

window字段，用于设置小程序的状态栏、导航条、标题、窗口背景色。[全局配置 | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#window)

```json
{
  "pages": [
    "pages/index/index",
    "pages/logs/index"
  ],
  "window": {
    "navigationBarBackgroundColor": "#000",
    "navigationBarTextStyle": "white",
    "navigationBarTitleText": "小程序"
  }
}
```

![image-20221015081519071](image-20221015081519071.png)

## app.js

除了app.json文件，全局还应该有一个app.js文件，[注册小程序 | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/app.html)

每个小程序都需要在 `app.js` 中调用 `App` 方法注册小程序实例，绑定生命周期回调函数、错误监听和页面不存在监听函数等。

```js
// app.js
App({
  onLaunch (options) {
    // Do something initial when launch.
  },
  onShow (options) {
    // Do something when show.
  },
  onHide () {
    // Do something when hide.
  },
  onError (msg) {
    console.log(msg)
  },
  globalData: 'I am global data'
})
```

## app.wxss

全局公共样式，[WXSS | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html)

## 编写页面

修改pages/index/index.wxml

`view`标签相当于`div`，`text`标签相当于`span`

```html
<!--pages/index/index.wxml-->
<view>
  <image src="/static/images/nvsheng.jpg"></image>
  <text>北方汉子</text>
  <view>
    <text>Hello World</text>
  </view>
</view>
```

微信开发者工具，不支持文件的复制，可以在本地文件夹复制下（静态资源：）

路径直接从根路径开始写，保存查看页面

![image-20221015083222527](image-20221015083222527.png)

添加类名开始写样式

```html
<!--pages/index/index.wxml-->
<view class="indexContainer">
  <image class="avatarUrl" src="/static/images/nvsheng.jpg"></image>
  <text class="url">北方汉子</text>
  <view class="goStudy">
    <text>Hello World</text>
  </view>
</view>
```

index.wxss

不能用px作为单位，否则盒子大小不会随着机型分辨率的变化而变化，如果写100px，在任何机型上就都是100px，需要做一下适配（用微信提供的rpx单位）

在iphone6上是100px，随着屏幕变大，在6 plus上的盒子大小应该大一点

那么还能是100rpx吗？不能

- rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。
- [WXSS | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html)

```css
/* pages/index/index.wxss */

/* 最外层包了个page标签，相当于body */
/* page放这里不合适，小程序会给每个页面都加一个page标签，其他页面想用就用不了，放到公共样式app.wxss里 */
/* page {
  height: 100%;
} */
.indexContainer {
  display: flex;
  flex-direction: column;
  align-items: center;
  background-color: aliceblue; /*由于是flex布局，高度被内容撑开，不是全屏的*/
  height: 100%;
}
.avatarUrl {
  width: 200rpx;
  height: 200rpx;
  border-radius: 50%;
  margin: 100rpx 0;
}
.userName {
  font-size: 32rpx;
  margin: 100rpx 0;

}
.goStudy {
  width: 300rpx;
  height: 80rpx;
  line-height: 80rpx;
  text-align: center;
  font-size: 28rpx;
  border: 1px solid #333;
  border-radius: 10rpx;
}
```

app.wxss

```css
/* app.wxss */
page {
  height: 100%;
}
```

效果：

![image-20221015090618161](image-20221015090618161.png)

优化：图片很明显尺寸不对

原生小程序的wxss不支持background-image的import导入，https://www.wzjm.cn/phper/90.html，

- 可以使用内联样式后，使用background的属性

  ```html
   <view class="avatarUrl" style="background-image:url(/static/images/nvsheng.jpg)"> </view>
  
  ```

  ```css
  .avatarUrl {
    width: 200rpx;
    height: 200rpx;
    border-radius: 50%;
    margin: 100rpx 0;
    background-size: cover;
    background-position: center;
    /* background-image: url('static/images/nvsheng.jpg');  */
  }
  ```

直接使用image的`object-fit:cover`也没有生效，小程序不支持此属性，官方提供了自己的方法，mode属性。[image | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/component/image.html)

╭(╯^╰)╮

```html
  <image class="avatarUrl" src="/static/images/nvsheng.jpg" mode="aspectFill"></image>

```

```css
.avatarUrl {
  width: 200rpx;
  height: 200rpx;
  border-radius: 50%;
  margin: 100rpx 0;
}
```

效果，头像不再是压缩的了：

![image-20221015094047301](image-20221015094047301.png)

## 获取用户信息

前置知识：了解完`小程序语法`这一小节

### 点击获取用户信息

[button | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/component/button.html)

```html
  <image class="avatarUrl" src="{{userInfo.avatarUrl}}" mode="aspectFill"></image>
  <button type="primary" open-type="getUserInfo" bindgetuserinfo="handleGetUserInfo">点击授权</button>
  <text class="userName">{{userInfo.nickName}}</text>
```



```js
  data: {
    msg: '初始化数据',
    userInfo: {}, //初始化用户数据
  },
  handleGetUserInfo(res) {
    console.log(res)
    if(res.detail.userInfo) {
      this.setData({
        userInfo: res.detail.userInfo
      })
    }
  },
```

详细参考官网，button按钮的`open-type="getUserInfo"`是开放的api，通过bindgetuserinfo绑定自定义回调，参数是点击后的详细信息

![image-20221015190308372](image-20221015190308372.png)

目前上面的写法，每次重新进入小程序，已经授权的用户信息会丢失，见下一小节

### onLoad时获取用户信息

什么时候获取用户信息？

- 越早越好，因为要显示

- 放在onLoad里，使用`wx.getUserInfo`，[wx.getUserInfo(Object object) | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/user-info/wx.getUserInfo.html)

  ```js
    onLoad(options) {
      console.log('我加载啦')
      wx.getUserInfo({
        success: (res) => { // 要用箭头函数，回调函数被调用时，是wx页面实例调的
          console.log('获取授权成功', res)
          this.setData({
            userInfo: res.userInfo
          })
        },
        fail: (err) => {
          console.log('获取授权失败', err)
        }
      })
    },
  ```

  ![image-20221015192210943](image-20221015192210943.png)

- 由于之前的api，获取用户信息需要用户点击授权确认，放在onLoad里，是为了第二次进入小程序时，直接获取授权后的用户信息

  - 现在没那个弹出窗口了，进入时，后台直接就获取成功的结果了



使用条件渲染，优化代码：没授权时，头像和昵称的结构不应该显示

```html
  <image wx:if="{{userInfo.avatarUrl}}" class="avatarUrl" src="{{userInfo.avatarUrl}}" mode="aspectFill"></image>
  <button wx:else type="primary" open-type="getUserInfo" bindgetuserinfo="handleGetUserInfo">点击授权</button>
  <text wx:if="{{userInfo.avatarUrl}}" class="userName">{{userInfo.nickName}}</text>
```

## 窗口配置和轮播图

新建一个空项目

在全局设置窗口颜色

```json
    "window": {
        "backgroundTextStyle": "light",
        "navigationBarBackgroundColor": "#d43c33",
        "navigationBarTitleText": "云音乐",
        "navigationBarTextStyle": "white"
    },
```

![image-20221015194312378](image-20221015194312378.png)



使用swiper组件，[swiper | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/component/swiper.html)

```html
<!--index.wxml-->
<view class="container">
  <!-- 轮播图区域 -->
  <swiper class="banners" indicator-dots indicator-color="ivory" indicator-active-color="#d43c33" autoplay interval="5000" circular>
    <swiper-item>
      <image mode="aspectFill" src="/static/images/nvsheng.jpg"></image>
    </swiper-item>
    <swiper-item>
      <image mode="aspectFill" src="/static/images/nvsheng.jpg"></image>
    </swiper-item>
    <swiper-item>
      <image mode="aspectFill" src="/static/images/nvsheng.jpg"></image>
    </swiper-item>
  </swiper>
</view>

```

![image-20221015200104128](image-20221015200104128.png)

## 使用IDE开发微信小程序

### vscode

- 识别wxss和wxml文件

  - 选择设置【Ctrl+，】或通过管理-设置

  - 选择右上角图标，第二个图标

    ![image-20221015200604684](image-20221015200604684.png)

  - 在setting.json中添加如下代码

    ```json
    "files.associations": { "*.wxml": "html", "*.wxss": "css"},
    ```

- 安装相应插件

  - 小程序开发助手

    ![image-20221015200920631](image-20221015200920631.png)

  - WXML：微信小程序wxml格式化以及高亮组件(高度自定义)

    ![image-20221015200903093](image-20221015200903093.png)

  - WXSS－peek：为wxss样式提供跳转到定义功能

    ![image-20221015201053219](image-20221015201053219.png)

  - vscode weapp api：为vscode提供小程序[API](https://so.csdn.net/so/search?q=API&spm=1001.2101.3001.7020)提示及代码片段

- vscode开发小程序只是起到了编辑的效果，真正的调试等还需要在小程序开发工具中进行。

## 微信小程序中使用字体图标

阿里图标库选好图标后，由于是css，需要手动复制到wxss文件中，和平时项目中使用iconfont一样，使用类名

如果图标没出来，重启下微信开发者工具

```html
  <!-- 五个图标导航区域 -->
  <view class="navContainer">
    <view class="navItem">
      <text class="iconfont icon-tuijian"></text>
      <text class="desc">每日推荐</text>
    </view>
    <view class="navItem">
      <text class="iconfont icon-gedan"></text>
      <text class="desc">歌单</text>
    </view>
    <view class="navItem">
      <text class="iconfont icon-paixingbang"></text>
      <text class="desc">排行榜</text>
    </view>
    <view class="navItem">
      <text class="iconfont icon-tuijian"></text>
      <text class="desc">电台</text>
    </view>
    <view class="navItem">
      <text class="iconfont icon-zhibo"></text>
      <text class="desc">直播</text>
    </view>
  </view>
```



```css

.navContainer {
  display: flex;
}

.navItem {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 20%;
}

.navItem .iconfont {
  width: 100rpx;
  height: 100rpx;
  margin: 20rpx 0;
  background-color: rgb(240, 19, 19);
  border-radius: 50%;
  font-size: 50rpx;
  line-height: 100rpx;
  text-align: center;
  color: #fff;
}

.navItem .desc {
  font-size: 26rpx;
}
```

效果：

![image-20221016102622176](image-20221016102622176.png)

## 推荐歌曲

scroll-view，可滚动的试图区域，[scroll-view | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/component/scroll-view.html)

该组件需要设置enable-flex属性为true，设置flex才会生效

```html
  <!-- 推荐歌曲区域 -->
  <view class="recommendContainer">
    <view class="header">
      <text class="title">123</text>
      <view class="item">
        <text class="desc">为你精心推荐</text>
        <text class="more">查看更多</text>
      </view>
    </view>
    <!-- 内容区 -->
    <scroll-view class="recommendScroll" enable-flex scroll-x>
      <view class="scrollItem">
        <image mode="aspectFill" src="/static/images/nvsheng.jpg"></image>
        <text>推荐歌曲内容区</text>
      </view>
      <view class="scrollItem">
        <image mode="aspectFill" src="/static/images/nvsheng.jpg"></image>
        <text>推荐歌曲内容区</text>
      </view>
      <view class="scrollItem">
        <image mode="aspectFill" src="/static/images/nvsheng.jpg"></image>
        <text>推荐歌曲内容区推荐歌曲内容区</text>
      </view>
      <view class="scrollItem">
        <image mode="aspectFill" src="/static/images/nvsheng.jpg"></image>
        <text>推荐歌曲内容区推荐歌曲内容区</text>
      </view>
      <view class="scrollItem">
        <image mode="aspectFill" src="/static/images/nvsheng.jpg"></image>
        <text>推荐歌曲内容区推荐歌曲内容区</text>
      </view>
      <view class="scrollItem">
        <image mode="aspectFill" src="/static/images/nvsheng.jpg"></image>
        <text>aaaa</text>
      </view>
    </scroll-view>
      
  </view>
```



```css
/* 推荐歌曲开始 */
.recommendContainer {
  padding: 20rpx;
}
.recommendContainer .header {
  margin-bottom: 20rpx;
}
.recommendContainer .header .title {
  font-size: 32rpx;
  line-height: 40rpx;
  color: #666;
}
.recommendContainer .header .item {
  height: 60rpx;
}
.recommendContainer .header .desc {
  font-size: 30rpx;
  line-height: 60rpx;
}
.recommendContainer .header .more {
  float: right;
  padding: 10rpx 20rpx;
  border: 1px solid #333;
  border-radius: 30rpx;
  font-size: 24rpx;
}
/* 推荐歌曲内容区开始 */
.recommendScroll {
  display: flex;
}
.scrollItem {
  width: 200rpx;
  margin-right: 20rpx;
}
.scrollItem image {
  width: 200rpx;
  height: 200rpx;
  border-radius: 10rpx;
}
.scrollItem text {
  font-size: 26rpx;
  /* 单行文本溢出 */
  /* display: block;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis; */

  /* 多行文本溢出 */
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 2;
}
/* 推荐歌曲内容区结束 */

/* 推荐歌曲结束 */
```

## 前后端交互

网络基础说明文档：[网络 | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/framework/ability/network.html)

网易云音乐有自己的开放接口，我们用nodejs做一下中间层，分发路由

我们把服务部署在服务器上（也可以直接跑本地）

安装pm2管理

```bash
npm i pm2
npx pm2 start app.js --name music
```

![image-20221017230803035](image-20221017230803035.png)

接口文档及后台，见项目资料

正式编写代码时，用测试工具测试一下接口

微信中发送网络请求：[RequestTask | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/api/network/request/wx.request.html)

语法：wx.request()

注意点：

- 协议必须是https协议
- 一个接口最多配置20个域名
- 并发限制上限是10个

启动后台测试服务

![image-20221016183008646](image-20221016183008646.png)

在小程序后台配置接口地址，配置会失败

![image-20221016182917797](image-20221016182917797.png)

![image-20221016183305281](image-20221016183305281.png)

只能配已备案过的域名，如果是在企业开发，后台应该提供的是https的接口

- 包括：域名申请、付费、企业备案、接口部署



不过开发时，可以在开发者工具中，设置不校验合法域名

![image-20221016182731361](image-20221016182731361.png)

在onLoad或者onReady里面发送

`pages/index/index.js`

```js
// index.js
Page({
    data: {

    },
    onLoad: function(options) {
        console.log('index加载了')
        wx.request({
            url: 'http://localhost:3000/banner',
            data: {
                type: 2
            },
            success: (res) => {
                console.log('请求成功', res)
            },
            fail: (err) => {
                console.log('请求失败', err)
            }
        })
    }
})
```

请求成功：

![image-20221016184358852](image-20221016184358852.png)

## 封装请求功能函数

> 发送ajax请求
>
> 1.封装功能函数
>
> - 功能点明确
> - 函数内部应该保留固定代码（静态的）
> - 将动态的数据抽取成形参，由使用者根据自身的情况动态的传入实参
> - 一个良好的功能函数应该设置形参的默认值（ES6的形参默认值）
>
> 2.封装功能组件
>
> - 功能点明确
>
> - 组件内部保留静态代码
>
> - 将动态的数据抽取成props参数，由使用者根据自身的情况以标签属性的形式动态传入props数据
>
> - 一个良好的组件应该设置组件的必要性及数据类型
>
>   props: {
>
>   ​	msg: {
>
>   ​		required:  true,
>
>   ​		default: 默认值,
>
>   ​		type: String
>
>   ​	}
>
>   }

新建`utils/request.js`

```js
import config from './config.js'
export default (url, data = {}, method = 'GET') => {
    return new Promise((resolve, reject) => {
        wx.request({
            url: config.host + url,
            data,
            success: (res) => {
                console.log('请求成功', res)
                resolve(res.data)
            },
            fail: (err) => {
                console.log('请求失败', err)
                reject(err)
            }
        })
    })
}
```

新建配置文件

`utils/config.js`

```js
// 服务器配置相关
export default {
    host: 'http://localhost:3000'
}
```

发送请求

```js
// index.js
import request from '../../utils/request.js'
Page({
    data: {

    },
    onLoad: async function(options) {
        console.log('index加载了')
        let result = await request('/banner', {type: 2})
        console.log(result)
    }
})
```

## 渲染轮播图数据

```html
  <!-- 轮播图区域 -->
  <swiper class="banners"	indicator-dots indicator-color="ivory" indicator-active-color="#d43c33" autoplay 	interval="5000" circular>
    <swiper-item wx:for="{{bannerList}}" wx:key="bannerId">
      <image mode="aspectFill" src="{{item.pic}}"></image>
    </swiper-item>
  </swiper>
```

```js
// index.js
import request from '../../utils/request.js'
Page({
    data: {
        bannerList: []
    },
    onLoad: async function(options) {
        console.log('index加载了')
        let bannerListData = await request('/banner', {type: 2})
        console.log(bannerListData)
        this.setData({
            bannerList: bannerListData.banners
        })
    }
})
```

效果

![image-20221016213848906](image-20221016213848906.png)

## 推荐歌曲动态实现

```html
  <!-- 推荐歌曲区域 -->
  <view class="recommendContainer">
    <view class="header">
      <text class="title">推荐歌曲</text>
      <view class="item">
        <text class="desc">为你精心推荐</text>
        <text class="more">查看更多</text>
      </view>
    </view>
    <!-- 内容区 -->
    <scroll-view class="recommendScroll" enable-flex scroll-x>
      <view class="scrollItem" wx:for="{{recommendList}}" wx:key="id">
        <image mode="aspectFill" src="{{item.picUrl}}"></image>
        <text>{{item.name}}</text>
      </view>
    </scroll-view>
  </view>
```

```js
// index.js
import request from '../../utils/request.js'
Page({
    data: {
        bannerList: [], // 轮播图数据
        recommendList: [], // 推荐歌单数据
    },
    onLoad: async function(options) {
        console.log('index加载了')

        // 获取轮播图数据
        let bannerListData = await request('/banner', {type: 2})
        this.setData({
            bannerList: bannerListData.banners
        })

        // 获取歌单数据
        let recommendListData = await request('/personalized', {limit: 10})
        this.setData({
            recommendList: recommendListData.result
        })
    }
})
```

效果：

![image-20221016215310501](image-20221016215310501.png)

## 自定义组件

[Component(Object object) | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Component.html)

新建`components/NavHeader`，及对应的4个文件

定义组件

```html
<!--components/NavHeader.wxml-->
<view class="header">
    <text class="title">推荐歌曲</text>
    <view class="item">
      <text class="desc">为你精心推荐</text>
      <text class="more">查看更多</text>
    </view>
</view>
```

```css
/* components/NavHeader.wxss */
.header {
    margin-bottom: 20rpx;
  }
.header .title {
    font-size: 32rpx;
    line-height: 40rpx;
    color: #666;
}
.header .item {
    height: 60rpx;
}
.header .desc {
    font-size: 30rpx;
    line-height: 60rpx;
}
.header .more {
    float: right;
    padding: 10rpx 20rpx;
    border: 1px solid #333;
    border-radius: 30rpx;
    font-size: 24rpx;
}
```

`index.json`中注册组件

```json
{
  "usingComponents": {
    "NavHeader": "/components/NavHeader/NavHeader"
  }
}
```

使用组件

```html
  <!-- 推荐歌曲区域 -->
  <view class="recommendContainer">
    <NavHeader></NavHeader>
    <!-- 内容区 -->
    <scroll-view class="recommendScroll" enable-flex scroll-x>
      <view class="scrollItem" wx:for="{{recommendList}}" wx:key="id">
        <image mode="aspectFill" src="{{item.picUrl}}"></image>
        <text>{{item.name}}</text>
      </view>
    </scroll-view>
  </view>
  
  <!-- 排行榜区域 -->
  <view>
    <!-- 头部区域 -->
    <NavHeader></NavHeader>
    <!-- 内容区域 -->
  </view>
```

调整scrollView的高度

```css
.recommendScroll {
  display: flex;
  height: 300rpx;
}
```

## 排行榜

增加样式

```css
/* 排行榜开始 */
.topList {
  padding: 20rpx;
  padding-top: 0;
}
.topListSwiper {
  height: 400rpx;
}
.swiperItem {
  width: 96%;
  background-color: #fbfbfb;
}
.swiperItem .title {
  font-size: 30rpx;
  line-height: 80rpx;
}
.musicItem {
  display: flex;
  margin-bottom: 20rpx;
}

.musicItem image {
  width: 100rpx;
  height: 100rpx;
  border-radius: 6rpx;
}

.musicItem .count {
  width: 100rpx;
  height: 100rpx;
  text-align: center;
  line-height: 100rpx;
}

.musicItem .musicName {
  height: 100rpx;
  line-height: 100rpx;
  max-width: 400rpx;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
/* 排行榜结束 */
```



组件封装时，我们需要传入动态的数据

`NavHeader.js`

```js
// components/NavHeader.js
Component({
  /**
   * 组件的属性列表
   */
  properties: {
    title: {
      type: String,
      value: '我是title默认值'
    },
    nav: {
      type: String,
      value: '我是nav默认值'
    }
  },

  /**
   * 组件的初始数据
   */
  data: {

  },

  /**
   * 组件的方法列表
   */
  methods: {

  }
})

```



```html
  <!-- 推荐歌曲区域 -->
  <view class="recommendContainer">
    <NavHeader title="推荐歌曲" nav="为你精心推荐"></NavHeader>
    <!-- 内容区 -->
    <scroll-view class="recommendScroll" enable-flex scroll-x>
      <view class="scrollItem" wx:for="{{recommendList}}" wx:key="id">
        <image mode="aspectFill" src="{{item.picUrl}}"></image>
        <text>{{item.name}}</text>
      </view>
    </scroll-view>
  </view>
  
  <!-- 排行榜区域 -->
  <view class="topList">
    <!-- 头部区域 -->
    <NavHeader title="排行榜" nav="热歌风向标"></NavHeader>
    <!-- 内容区域 -->
    <swiper class="topListSwiper" circular next-margin="50rpx" previous-margin="50rpx">
      <swiper-item wx:for="{{topList}}" wx:key="name">
        <view class="swiperItem">
          <view class="title">
            {{item.name}}
          </view>
          <view class="musicItem" wx:for="{{item.tracks}}" wx:key="id" wx:for-item="musicItem">
            <image src="{{musicItem.al.picUrl}}"></image>
            <text class="count">{{index + 1}}</text>
            <text class="musicName">{{musicItem.name}}</text>
          </view>
        </view>
      </swiper-item>
    </swiper>
  </view>

```



```js
    data: {
		// ...
        topList: [], // 排行榜数据
    },


// 获取排行榜数据
        /**
         * 需求分析：
         *  1.需要根据idx的值获取对应的数据
         *  2.idx的取值范围是0-20，我们需要0-4
         *  3.需要发5次请求
         */
        let index = 0,
            resultArr = []
        while(index < 5) {
            let topListData = await request('/top/list', {idx: index++})
            let topListItem  = {
                name: topListData.playlist.name,
                tracks: topListData.playlist.tracks.slice(0, 3)
            }
            resultArr.push(topListItem)
            // 更新topList的值，发一次就更新一次（多渲染几次，牺牲点性能，用户体验较好，弱网用户不会有较长时间的白屏）
            this.setData({
                topList: resultArr
            })
        }
```

效果：

![image-20221018213944706](image-20221018213944706.png)



更新：最新接口已不支持idx形式调用，根据最新接口文档自行调整

![image-20221030185320382](image-20221030185320382.png)

```js
// index.js
import request from '../../utils/request.js'
Page({
    data: {
        bannerList: [], // 轮播图数据
        recommendList: [], // 推荐歌单数据
        topList: [], // 排行榜数据
    },
    onLoad: async function(options) {
        console.log('index加载了')

        // 获取轮播图数据
        let bannerListData = await request('/banner', {type: 2})
        this.setData({
            bannerList: bannerListData.banners
        })

        // 获取歌单数据
        let recommendListData = await request('/personalized', {limit: 10})
        this.setData({
            recommendList: recommendListData.result
        })

        // 获取排行榜数据
        /**
         * 需求分析：
         *  1.需要根据idx的值获取对应的数据
         *  2.idx的取值范围是0-20，我们需要0-4
         *  3.需要发5次请求
         */
        let index = 0,
            resultArr = []
        // while(index < 5) {
        //     let topListData = await request('/top/list', {idx: index++})
        //     let topListItem  = {
        //         name: topListData.playlist.name,
        //         tracks: topListData.playlist.tracks.slice(0, 3)
        //     }
        //     resultArr.push(topListItem)
        //     // 更新topList的值，发一次就更新一次（多渲染几次，用户体验较好，弱网用户不会有较长时间的白屏）
        //     this.setData({
        //         topList: resultArr
        //     })
        // }

        // 获取所有排行榜的信息，根据id字段获取歌单的详细信息（排行榜也是歌单的一种）
        let topListData = await request('/toplist')
        let list = topListData.list

        list.forEach(async (item, index) => {
            if(index < 5) {
                let {name, id} = item
                let listDetailData = await request('/playlist/detail', {id})
                console.log('aa',listDetailData)
                let topListItem = {
                    name,
                    tracks: listDetailData.playlist.tracks.slice(0, 3)
                }
                resultArr.push(topListItem)
            }
            index++
            this.setData({
                topList: resultArr
            })
        })





    }
})
```



## 内网穿透

真机调试时需要用到

但由于接口已经部署到服务器上了，可以公网访问，此小节跳过

## tabBar使用

微信开发者工具中，新建perosnal和video两个页面



tabBar配置，[全局配置 | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#tabBar)

微信开发者工具中，在app.json全局配置中，新增tabBar配置

```json
{
  "pages": [
    "pages/index/index",
    "pages/personal/personal",
    "pages/video/video"
  ],
  "window": {
    "backgroundTextStyle": "light",
    "navigationBarBackgroundColor": "#d43c33",
    "navigationBarTitleText": "云音乐",
    "navigationBarTextStyle": "white"
  },
  "style": "v2",
  "sitemapLocation": "sitemap.json",
  "tabBar": {
    "color": "#333",
    "selectedColor": "#d43c33",
    "backgroundColor": "#ffffff",
    "list": [
      {
      "pagePath": "pages/index/index",
      "text": "主页",
      "iconPath": "/static/myImages/tabs/tab-home.png",
      "selectedIconPath": "/static/myImages/tabs/tab-home-current.png"
      },
      {
        "pagePath": "pages/video/video",
        "text": "视频",
        "iconPath": "/static/myImages/tabs/video.png",
        "selectedIconPath": "/static/myImages/tabs/video-selected.png"
      },
      {
        "pagePath": "pages/personal/personal",
        "text": "主页",
        "iconPath": "/static/myImages/tabs/tab-my.png",
        "selectedIconPath": "/static/myImages/tabs/tab-my-current.png"
      }
    ]
  }
}
```

可以去阿里图标库里找一些好看的图标

## 个人中心静态页面

app.json中，先把个人中心页提到第一个

```html
<view class="personalContainer">
  <view class="user-section">
    <image mode="aspectFill" class="bg" src="/static/images/personal/bgImg2.jpg"></image>
    <view class="user-info-box" bindtap="toLogin">
      <view class="portrait-box">
        <image class="portrait" src='{{userInfo.avatarUrl?userInfo.avatarUrl:"/static/images/personal/missing-face.png"}}'></image>
      </view>
      <view class="info-box">
        <text class="username">{{userInfo.nickname?userInfo.nickname: '游客'}}</text>
      </view>
    </view>

    <view class="vip-card-box">
      <image class="card-bg" src="/static/images/personal/vip-card-bg.png" mode=""></image>
      <view class="b-btn">
        立即开通
      </view>
      <view class="tit">
        <!-- 会员图标-->
        <text class="iconfont icon-huiyuan-"></text>
        硅谷会员
      </view>
      <text class="e-m">atguigu Union</text>
      <text class="e-b">开通会员听歌</text>
    </view>
  </view>

  <view
      class="cover-container"
      bindtouchstart="handleTouchStart"
      bindtouchmove="handleTouchMove"
      bindtouchend="handleTouchEnd"
      style="transform: {{coverTransform}}; transition: {{coveTransition}}"
  >
    <image class="arc" src="/static/images/personal/arc.png"></image>
    <!-- 个人中心导航 -->
    <view class="nav-section">
      <view class="nav-item"  hover-class="common-hover"  hover-stay-time="50">
        <text class="iconfont icon-xiaoxi"></text>
        <text>我的消息</text>
      </view>
      <view class="nav-item"   hover-class="common-hover" hover-stay-time="50">
        <text class="iconfont icon-myRecommender"></text>
        <text>我的好友</text>
      </view>
      <view class="nav-item"  hover-class="common-hover"  hover-stay-time="50">
        <text class="iconfont icon-gerenzhuye"></text>
        <text>个人主页</text>
      </view>
      <view class="nav-item" hover-class="common-hover"  hover-stay-time="50">
        <text class="iconfont icon-gexingzhuangban"></text>
        <text>个性装扮</text>
      </view>
    </view>

    <!-- 个人中心列表 -->
    <view class="personalContent">
      <view class="recentPlayContainer">
        <text class="title">最近播放</text>
        <!-- 最近播放记录 -->
        <scroll-view wx:if="{{recentPlayList.length}}" scroll-x class="recentScroll" enable-flex>
          <view class="recentItem" wx:for="{{recentPlayList}}" wx:key="{{id}}">
            <image src="{{item.song.al.picUrl}}"></image>
          </view>
        </scroll-view>
        <view wx:else>暂无播放记录</view>
      </view>

      <view class="cardList">
        <view class="card-item">
          <text class="title">我的音乐</text>
          <text class="more"> > </text>
        </view>
        <view class="card-item">
          <text class="title">我的收藏</text>
          <text class="more"> > </text>
        </view>
        <view class="card-item">
          <text class="title">我的电台</text>
          <text class="more"> > </text>
        </view>
      </view>
    </view>
  </view>


</view>

```



```css
/* pages/personal/personal.wxss */
.personalContainer {
  width: 100%;
  height: 100%;
}

.personalContainer .user-section {
  height: 520rpx;
  position: relative;
  padding: 100rpx 30rpx 0;
}
.user-section .bg {
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  opacity: 0.95;
  filter: blur(1px);

}


.user-info-box{
  height: 180rpx;
  display:flex;
  align-items:center;
  position:relative;
  z-index: 1;

}

.user-info-box .portrait{
  width: 130rpx;
  height: 130rpx;
  border:5rpx solid #fff;
  border-radius: 50%;
}
.user-info-box .username{
  font-size: 24;
  color: #303133;
  margin-left: 20rpx;
}


/* vip-box */
.vip-card-box {
  position: relative;
  display: flex;
  flex-direction: column;
  background: linear-gradient(left, red, black);
  background: rgba(0, 0, 0, .7);
  height: 240rpx;
  color: #f7d680;
  border-radius: 16rpx 16rpx 0 0;
  padding: 20rpx 24rpx;
}


.vip-card-box .card-bg{
  position:absolute;
  top: 20rpx;
  right: 0;
  width: 380rpx;
  height: 260rpx;
}

.vip-card-box .b-btn{
  position: absolute;
  right: 20rpx;
  top: 16rpx;
  width: 132rpx;
  height: 40rpx;
  text-align: center;
  line-height: 40rpx;
  font-size: 22rpx;
  color: #36343c;
  border-radius: 20px;
  background: #f9e6af;
  z-index: 1;
}

.vip-card-box .b-btn{
  position: absolute;
  right: 20rpx;
  top: 16rpx;
  width: 132rpx;
  height: 40rpx;
  text-align: center;
  line-height: 40rpx;
  font-size: 22rpx;
  color: #36343c;
  border-radius: 20px;
  /*background: linear-gradient(left, #f9e6af, #ffd465);*/ /*渐变不生效*/
  background: #f9e6af;
  z-index: 1;
}

.vip-card-box .tit {
  font-size: 22rpx;
  color: #f7d680;
  margin-bottom: 28rpx;
}
.vip-card-box .tit .iconfont{
  color: #f6e5a3;
  margin-right: 16rpx;
}




.vip-card-box .e-m{
  font-size: 34rpx;
  margin-top: 10rpx;
}
.vip-card-box .e-b{
  font-size: 24rpx;
  color: #d8cba9;
  margin-top: 10rpx;
}


.cover-container{
  margin-top: -150rpx;
  padding: 0 30rpx;
  position:relative;
  background: #f5f5f5;
  padding-bottom: 20rpx;
}

.cover-container .arc{
  position:absolute;
  left: 0;
  top: -34rpx;
  width: 100%;
  height: 36rpx;
}


/* 导航部分 */
.cover-container .nav-section {
  display: flex;
  background: #fff;
  padding: 20rpx 0;
  border-radius: 15rpx;
}


.nav-section .nav-item {
  width: 25%;
  box-sizing: border-box;
  display: flex;
  flex-direction: column;
  align-items: center;
}

.nav-section .nav-item .iconfont {
  font-size: 50rpx;
  color: #d43c33;
  line-height: 70rpx;
}

.nav-section .nav-item text:last-child {
  font-size: 22rpx;

}


/* 个人中心列表 */
.personalContent {
  background: #fff;
  margin-top: 20rpx;
}

/* 最近播放 */
.personalContent .scrollView {
  display: flex;
  height: 160rpx;
}
.personalContent .recentPlay {
  display: flex;
}

.recentPlayContainer .title {
  padding-left: 20rpx;
  font-size: 26rpx;
  color: #333;
  line-height: 80rpx;
}

.personalContent .recentPlay image {
  width: 160rpx;
  height: 160rpx;
  margin-left: 20rpx;
  border-radius: 20rpx;
}


.cardList {
  margin-top: 20rpx;

}
.cardList .card-item{
  border-top: 1rpx solid #eee;
  height: 80rpx;
  line-height: 80rpx;
  padding: 10rpx;
  font-size: 26rpx;
  color: #333;
}
.cardList .card-item .more {
  float: right;
}

/* 最近播放记录 */
.recentScroll {
  display: flex;
  height: 200rpx;
}
.recentItem {
  margin-right: 20rpx;
}
.recentItem image {
  width: 200rpx;
  height: 200rpx;
  border-radius: 10rpx;
}

```

## 个人中心动画效果实现

不足：不够丝滑

- 二次touch的时候，会立即重置动画
- 下拉会有卡顿

```js
// pages/personal.js
let startY = 0,
  moveY = 0,
  moveDistance = 0;
Page({

  /**
   * 页面的初始数据
   */
  data: {
    coverTransform: 'translateY(0)',
    coverTransition: ''
  },

  /**
   * 生命周期函数--监听页面加载
   */
  onLoad(options) {

  },

  handleTouchStart(event) {
    // console.log('handleTouchStart')
    console.log(event)
    this.setData({
      coverTransition: ''
    })
    // 获取手指起始坐标
    startY = event.touches[0].clientY


  },
  handleTouchMove(event) {
    // console.log('handleTouchMove')
    moveY = event.touches[0].clientY
    moveDistance = moveY - startY
    // 动态更新coverTransform的状态值
    if(moveDistance <= 0) {
      return
    }
    if(moveDistance >= 80) {
      moveDistance = 80
    }
    this.setData({
      coverTransform: `translateY(${moveDistance}rpx)`
    })
  },
  handleTouchEnd() {
    // console.log('handleTouchEnd')
    this.setData({
      coverTransform: 'translateY(0rpx)',
      coverTransition: 'transform 0.5s linear'
    })
  },
  /**
   * 生命周期函数--监听页面初次渲染完成
   */
  onReady() {

  },

  /**
   * 生命周期函数--监听页面显示
   */
  onShow() {

  },

  /**
   * 生命周期函数--监听页面隐藏
   */
  onHide() {

  },

  /**
   * 生命周期函数--监听页面卸载
   */
  onUnload() {

  },

  /**
   * 页面相关事件处理函数--监听用户下拉动作
   */
  onPullDownRefresh() {

  },

  /**
   * 页面上拉触底事件的处理函数
   */
  onReachBottom() {

  },

  /**
   * 用户点击右上角分享
   */
  onShareAppMessage() {

  }
})
```

## 登录界面及表单数据收集

新建login页，配置app.json

登录流程：

- 前端验证
  - 验证用户信息（账号、密码）是否合法
  - 前端验证不通过就提示用户，不需要发请求给后端
  - 前端验证通过了，发请求（携带账号、密码（加密））给服务器
- 后端验证
  - 查询数据库，验证用户是否存在
  - 用户不存在，告诉前端密码或账户名错误
  - 用户存在，解密验证密码是否正确
  - 密码不正确，告诉前端密码或账户名错误
  - 密码正确，签发token，提示前端登录成功
- 前端获取token，存储在本地，每次请求携带token



```html

<view class="container">
  <view class="wrapper">
    <view class="left-top-sign">LOGIN</view>
    <view class="welcome">
      欢迎回来！
    </view>
    <view class="input-content">
      <view class="input-item">
        <text class="tit">手机号码</text>
        <input  type="text" placeholder="请输入手机号码" data-test="abc" data-type="phone" id="phone" bindinput="handleInput"/>
      </view>
      <view class="input-item">
        <text class="tit">密码</text>
        <input type="password"  placeholder="请输入密码" data-test="abc" data-type="password" id="password" bindinput="handleInput"/>
      </view>
    </view>
    <button class="confirm-btn" bindtap="login">登录</button>
    <view class="forget-section">
      忘记密码?
    </view>
  </view>
  <view class="register-section">
    还没有账号?
    <text >马上注册</text>
  </view>
</view>

```

```css
/* pages/login/login.wxss */
.wrapper{
  position:relative;
  z-index: 90;
  padding-bottom: 40rpx;
}

.left-top-sign{
  font-size: 120rpx;
  color: #f8f8f8;
  position:relative;
  left: -16rpx;
  letter-spacing: 2rpx;
}

.welcome{
  position:relative;
  left: 50rpx;
  top: -90rpx;
  font-size: 46rpx;
  color: #555;
}


.input-content{
  padding: 0 60rpx;
}
.input-item{
  display:flex;
  flex-direction: column;
  align-items:flex-start;
  justify-content: center;
  padding: 0 30rpx;
  background:#f8f6fc;
  height: 120rpx;
  border-radius: 4px;
  margin-bottom: 50rpx;

}

.input-item:last-child{
  margin-bottom: 0;
}
.input-item .tit{
  height: 50rpx;
  line-height: 56rpx;
  font-size: 30rpx;
  color: #606266;
}
.input-item input{
  height: 60rpx;
  font-size: 30rpx;
  color: #303133;
  width: 100%;
}
.confirm-btn{
  width: 630rpx!important;
  height: 76rpx;
  line-height: 76rpx;
  border-radius: 50rpx;
  margin-top: 70rpx;
  background: #d43c33;
  color: #fff;
  font-size: 32rpx;
  padding: 0;
}
.confirm-btn2:after{
  border-radius: 100px;
}

.forget-section{
  font-size: 28rpx;
  color: #4399fc;
  text-align: center;
  margin-top: 40rpx;
}

.register-section{
  position:absolute;
  left: 0;
  bottom: 50rpx;
  width: 100%;
  font-size: 28rpx;
  color: #606266;
  text-align: center;

}
.register-section text{
  color: #4399fc;
  margin-left: 10rpx;
}

```

```js
// pages/login.js
Page({

  /**
   * 页面的初始数据
   */
  data: {
    phone: '', // 手机号
    password: '', // 用户密码
  },
  handleInput(event) {
    // let type = event.currentTarget.id // phone || password 通过id传值
    let type = event.currentTarget.dataset.type 
    console.log(type, event.detail.value)
    this.setData({
      [type]: event.detail.value
    })
  },
  /**
   * 生命周期函数--监听页面加载
   */
  onLoad(options) {

  },

  /**
   * 生命周期函数--监听页面初次渲染完成
   */
  onReady() {

  },

  /**
   * 生命周期函数--监听页面显示
   */
  onShow() {

  },

  /**
   * 生命周期函数--监听页面隐藏
   */
  onHide() {

  },

  /**
   * 生命周期函数--监听页面卸载
   */
  onUnload() {

  },

  /**
   * 页面相关事件处理函数--监听用户下拉动作
   */
  onPullDownRefresh() {

  },

  /**
   * 页面上拉触底事件的处理函数
   */
  onReachBottom() {

  },

  /**
   * 用户点击右上角分享
   */
  onShareAppMessage() {

  }
})
```

[事件 | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html)

当只传递唯一标识时，可以通过id来传递

当传递多个自定义属性，可以通过`data-`的方式

## 登录字段验证

### 前端验证

界面交互API，[wx.showToast(Object object) | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.showToast.html)

```js
// pages/login.js
Page({

  /**
   * 页面的初始数据
   */
  data: {
    phone: '', // 手机号
    password: '', // 用户密码
  },
  handleInput(event) { // 收集表单数据
    // let type = event.currentTarget.id // phone || password 通过id传值
    let type = event.currentTarget.dataset.type 
    console.log(type, event.detail.value)
    this.setData({
      [type]: event.detail.value
    })
  },
  login() { // 登录的回调
    // 收集表单项数据
    let {phone , password} = this.data
    // 前端验证
    if(!phone) {
      // 提示用户
      wx.showToast({
        title: '手机号不能为空',
        icon: 'none'
      })
      return
    }

    // 定义正则
    let phoneReg = /^1(3|4|5|6|7|8|9)\d{9}$/
    if(!phoneReg.test(phone)) {
      wx.showToast({
        title: '手机号格式错误',
        icon: 'none'
      })
      return
    }

    if(!password) {
      wx.showToast({
        title: '密码不能为空',
        icon: 'none'
      })
      return
    }
  },

})
```

后端验证

```js
// pages/login.js
import request from '../../utils/request'
Page({

  /**
   * 页面的初始数据
   */
  data: {
    phone: '', // 手机号
    password: '', // 用户密码
  },
  handleInput(event) { // 收集表单数据
    // let type = event.currentTarget.id // phone || password 通过id传值
    let type = event.currentTarget.dataset.type 
    console.log(type, event.detail.value)
    this.setData({
      [type]: event.detail.value
    })
  },
  async login() { // 登录的回调
    // 收集表单项数据
    let {phone , password} = this.data
    // 前端验证
    if(!phone) {
      // 提示用户
      wx.showToast({
        title: '手机号不能为空',
        icon: 'none'
      })
      return
    }

    // 定义正则
    let phoneReg = /^1(3|4|5|6|7|8|9)\d{9}$/
    if(!phoneReg.test(phone)) {
      wx.showToast({
        title: '手机号格式错误',
        icon: 'none'
      })
      return
    }

    if(!password) {
      wx.showToast({
        title: '密码不能为空',
        icon: 'none'
      })
      return
    }

    // 后端验证
    let res = await request('/login/cellphone', {phone, password})
    // 实际开发中，要考虑多种状态码的情况

    switch (res.code){
      case 200:
        wx.showToast( {
          title: '登录成功'
        })
        break
      case 400:
        wx.showToast({
          title: '手机号或密码错误',
          icon: 'none'
        })
        break
      case 502:
        wx.showToast({
          title: '手机号或密码错误',
          icon: 'none'
        })
        break
      default:
        wx.showToast({
          title: res.message || '登录失败，请重新登录',
          icon: 'none'
        })
    }


  },

})
```

## 个人中心、登录页面交互（本地存储）

把个人中心页在app.json中提到第一页

数据本地存储，[wx.setStorage(Object object) | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.setStorage.html)

personal.js

```js
// pages/personal.js
let startY = 0,
  moveY = 0,
  moveDistance = 0;
Page({

  /**
   * 页面的初始数据
   */
  data: {
    coverTransform: 'translateY(0)',
    coverTransition: '',
    userInfo: {}
  },

  /**
   * 生命周期函数--监听页面加载，只执行一次
   */
  onLoad(options) {
    let localUserInfo = wx.getStorageSync('userInfo')
    if(localUserInfo) {
      // 更新userInfo状态
      this.setData({
        userInfo: JSON.parse(localUserInfo)
      })
    }
  },

  handleTouchStart(event) {
    // console.log('handleTouchStart')
    console.log(event)
    this.setData({
      coverTransition: ''
    })
    // 获取手指起始坐标
    startY = event.touches[0].clientY


  },
  handleTouchMove(event) {
    // console.log('handleTouchMove')
    moveY = event.touches[0].clientY
    moveDistance = moveY - startY
    // 动态更新coverTransform的状态值
    if(moveDistance <= 0) {
      return
    }
    if(moveDistance >= 80) {
      moveDistance = 80
    }
    this.setData({
      coverTransform: `translateY(${moveDistance}rpx)`
    })
  },
  handleTouchEnd() {
    // console.log('handleTouchEnd')
    this.setData({
      coverTransform: 'translateY(0rpx)',
      coverTransition: 'transform 0.5s linear'
    })
  },
  // 跳转到登录页面
  toLogin() {
    wx.navigateTo({
      url: '/pages/login/login'
    })
  },

})
```

login.js

```js
switch (res.code){
      case 200:
        wx.showToast( {
          title: '登录成功'
        })
        // 本地存储个人信息
        wx.wx.setStorage({
          key: 'userinfo',
          data: JSON.stringify(res.profile)
        })
        // 跳转到个人中心
        wx.reLaunch({ // perosnal获取本地数据放在了onload里，用reLauch方法保证onload回调会重新执行，当然也可以不把读取用户数据的方法放在onLoad里，放在onShow里面（性能不太好，每次页面显示都会执行）
          url: '/pages/personal/personal'
        })
        break
        
        // ...
```

personal.wxml

```html
      <view class="portrait-box">
        <image class="portrait" src='{{userInfo.avatarUrl ? userInfo.avatarUrl : "/static/images/personal/missing-face.png"}}'></image>
      </view>
      <view class="info-box">
        <text class="username">{{userInfo.nickname ? userInfo.nickname : '游客'}}</text>
      </view>
```

## 获取用户播放记录

```js
  onLoad(options) {
    try {
      let localUserInfo = wx.getStorageSync('userinfo')
      // console.log(localUserInfo)
      if(localUserInfo) {
        // 更新userInfo状态
        this.setData({
          userInfo: JSON.parse(localUserInfo)
        })
      }

      // 获取用户播放记录
      this.getUserRecentPlayList(this.data.userInfo.userId)
    } catch(err) {
      console.log(err)
    }
    
  },
  async getUserRecentPlayList(userId) {
    let recentPlayListData = await request('/user/record',{uid: userId, type: 0})
    console.log(recentPlayListData)
    let index = 0
    // 构造数组每一项，添加id
    let recentPlayList= recentPlayListData.allData.splice(0, 10).map(item => {
      item.id = index++
      return item
    })
    this.setData({
      recentPlayList
    })
  },
```

![image-20221030221454399](image-20221030221454399.png)



## video导航区域

```js
// pages/video/video.js
import request from '../../utils/request'
Page({

  /**
   * 页面的初始数据
   */
  data: {
    videoGroupList: [], // 导航的标签数据（命名和接口保持一致）
    navId: 0, // 导航的标识
  },

  /**
   * 生命周期函数--监听页面加载
   */
  onLoad(options) {
    // 获取导航标签数据
    this.getVideoGroupListData()
  },
  async getVideoGroupListData() {
    let videoGroupListData = await request('/video/group/list')
    this.setData({
      videoGroupList: videoGroupListData.data.slice(0, 14),
      navId: videoGroupListData.data[0].id
    })

    // 拿到navId后，获取视频列表数据
    this.getVideoList(this.data.navId)
  },
  // 点击切换导航的回调
  changeNav(event) {
    let navId = Number(event.currentTarget.id)
    this.setData({
      navId
    })
  },
  // 获取视频列表数据
  async getVideoList(navId) {
    if(!navId) return
    let videoListData = await request('/video/group', {id: navId})
    console.log(videoListData)
  },

})
```



```html
<!--pages/video/video.wxml-->
<view class="videoContainer">
    <!-- 头部区域 -->
    <view class="header">
        <image src="/static/images/video/video.jpg" mode="aspectFit" lazy-load="false" binderror="" bindload="" />
        <view class="search">搜索商品</view>
        <image src="/static/images/logo.png" mode="aspectFit" lazy-load="false" binderror="" bindload="" />
    </view>

    <!-- 导航区域 -->
    <scroll-view scroll-x="true" class="navScroll" enable-flex>
        <view class="navItem" wx:for="{{videoGroupList}}" wx:key="id">
            <view class="navContent {{navId === item.id ? 'active' : ''}}" bindtap="changeNav" id="{{item.id}}">{{item.name}}</view>
        </view>
        
    </scroll-view>
      
</view>
```

```css
/* pages/video/video.wxss */
.videoContainer .header {
    display: flex;
    padding: 10rpx;
}
.videoContainer .header image {
    width: 60rpx;
    height: 60rpx;
}
.videoContainer .header .search {
    border: 1px solid #eee;
    flex: 1;
    margin: 0 20rpx;
    font-size: 26rpx;
    text-align: center;
    line-height: 60rpx;
    color: #d43c33;
}

/* 导航区域 */

.navScroll {
    display: flex;
    white-space: nowrap;
}

.navScroll .navItem {
    height: 60rpx;
    line-height: 60rpx;
    padding: 0 30rpx;
    font-size: 28rpx;
}

.navItem .active {
    border-bottom: 1px solid #d43c33;
}
```

## 保存cookie

由于封装request时，返回的是res.data，但cookie在res中，所以需要在request.js中处理cookie

不直接判断请求是否包含login，而是通过传参控制

`login.js`

```js
// 后端验证
    let res = await request('/login/cellphone', {phone, password, isLogin: true})
```

`request.js`

```js
        wx.request({
            url: config.host + url,
            data,
            success: (res) => {
                console.log('请求成功', res)
                // 登录请求
                if(data.isLogin) {
                    console.log('hasCookie')
                    wx.setStorage({
                        key: 'cookie',
                        data: res.cookie
                    })
                }
                resolve(res.data)
            },
            fail: (err) => {
                console.log('请求失败', err)
                reject(err)
            }
        })
```

但是，人家接口改了，cookie放到了res.data里，所以还是在登录成功的回调里保存cookie

```js
case 200:
        wx.showToast( {
          title: '登录成功'
        })
        // 本地存储个人信息
        wx.setStorage({
          key: 'userinfo',
          data: JSON.stringify(res.profile)
        })
		// 存储cookie
        wx.setStorage({
          key: 'cookie',
          data: res.cookie
        })
        // 跳转到个人中心
        wx.reLaunch({ // perosnal获取本地数据放在了onload里，用reLauch方法保证onload回调会重新执行，当然也可以不把读取用户数据的方法放在onLoad里，放在onShow里面（性能不太好，每次页面显示都会执行）
          url: '/pages/personal/personal'
        })
        break
```

在request.js中设置发送请求的请求头，获取cookie时使用同步获取

```js
        wx.request({
            url: config.host + url,
            data,
            header: {
                cookie: wx.getStorageSync('cookie') // 同步获取cookie
            },
            success: (res) => {
                console.log('请求成功', res)
                resolve(res.data)
            },
            fail: (err) => {
                console.log('请求失败', err)
                reject(err)
            }
        })
```

获取标签下的视频，这个接口的`offset`参数必需带上（文档上说是可选...）

## 视频列表动态显示

使用到了`Promise.all`方法，map方法迭代时，需要再一次发送异步方法，相当于map的时候，发送了多个异步请求，用`Promise.all`包裹一下，不然会报错

```js
// 获取视频列表数据
  async getVideoList(navId) {
    if(!navId) return

    let videoListData = await request('/video/group', {id: navId, offset: 0}) // 还要传一个offset参数
    // console.log(videoListData)
    let index = 0
    let videoList = await Promise.all(videoListData.datas.map(async item => {
      item.id = index++
      let urlInfo = await request('/video/url', {id: item.data.vid})
      item.dealedUrl = urlInfo.urls[0].url
      return item
    }))

    this.setData({
      videoList
    })
  },
```



但这种写法，真机调试时，会报`videoListData.datas`是`undefined`，要把拿出来

实际上发现，其实就是`/video/group`前面的这个接口，报302没拿到数据！！估计跟NodeJS中间件的做了2分钟缓存有关，重新清除下数据，又可以拿到了

```js
// 获取视频列表数据
  async getVideoList(navId) {
    if(!navId) return

    let videoListData = await request('/video/group', {id: navId, offset: 0}) // 还要传一个offset参数
    // console.log(videoListData)

    let index = 0
    let datas = videoListData.datas
    let videoList = await Promise.all(datas.map(async item => {
      item.id = index++
      let urlInfo = await request('/video/url', {id: item.data.vid})
      item.dealedUrl = urlInfo.urls[0].url
      return item
    }))

    this.setData({
      videoList
    })
  },
```

调整下样式





# 小程序语法

## 数据绑定

[WXML | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/)

页面.js文件的data配置项中初始化数据

```js
// pages/index/index.js
Page({

  /**
   * 页面的初始数据
   */
  data: {
    msg: '初始化数据'
  },

  /**
   * 生命周期函数--监听页面加载
   */
  onLoad(options) {

  },

  /**
   * 生命周期函数--监听页面初次渲染完成
   */
  onReady() {

  },

  /**
   * 生命周期函数--监听页面显示
   */
  onShow() {

  },

  /**
   * 生命周期函数--监听页面隐藏
   */
  onHide() {

  },

  /**
   * 生命周期函数--监听页面卸载
   */
  onUnload() {

  },

  /**
   * 页面相关事件处理函数--监听用户下拉动作
   */
  onPullDownRefresh() {

  },

  /**
   * 页面上拉触底事件的处理函数
   */
  onReachBottom() {

  },

  /**
   * 用户点击右上角分享
   */
  onShareAppMessage() {

  }
})
```

控制台中AppData菜单可以看到，小程序页面中用到的数据都来自这里

![image-20221015094904328](image-20221015094904328.png)

使用模板语法使用数据

```html
  <text class="userName">{{msg}}</text>
```

![image-20221015094944879](image-20221015094944879.png)

修改msg状态：`this.setData`，this代表当前页面的实例对象

```js
 onLoad(options) {
    console.log(this)
    this.setData({
      msg: '修改之后的数据'
    })
  },
```

在非自身的回调函数中，修改也是同步的

```js
  onLoad(options) {
    console.log(this.msg)
    setTimeout(() => {
      this.setData({
        msg: '修改之后的数据'
      })
    },2000)
  },

```

小结：

- 小程序：

  - data中初始化数据

  - 修改数据：this.setData()
    - 修改数据的行为始终是同步的
  - 数据流：
    - 单向：Model => View

- Vue：
  - data中初始化数据
  - 修改数据：this.key = value
  - 数据流：
    - Vue是单向数据流：Model => View
    - Vue中实现了双向数据绑定
- React：
  - state中初始化数据状态
  - 修改数据：
    - 自身钩子函数中（componentDidMount）异步的
    - 非自身的钩子函数中（定时器的回调）同步的
  - 数据流：
    - 单向：Model => View



小程序中的数据代理用的是Object.defineProperty()

## 事件绑定

[事件 | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html)

1.bind绑定：事件绑定不会阻止冒泡事件向上冒泡

```html
<view bindtap="handleTap">
	<text></text>
</view>
```

2.catch绑定：事件绑定可以阻止冒泡事件向上冒泡

```html
<view catchtap="handleTap">
	<text></text>
</view>
```



自定义事件写在*.js中，与data评级

```js
 handleTap() {
    console.log('hello world')
  },
```



## 路由跳转

[wx.navigateTo(Object object) | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateTo.html)

页面配置

app.json

```json
{
  "pages": [
    "pages/index/index",
    "pages/logs/index"
  ],
  "window": {
    "navigationBarBackgroundColor": "#fff",
    "navigationBarTextStyle": "black",
    "navigationBarTitleText": "小程序"
  }
}
```

设置跳转

```js
  handleTap() {
    console.log('hello world')
    wx.navigateTo({
      url: '/pages/logs/index', // 这里要加根路径/
    })
  },
```

![image-20221015154910766](image-20221015154910766.png)

`wx.redirectTo(Object object)`的效果

```js
  handleTap() {
    console.log('hello world')
    wx.redirectTo({
      url: '/pages/logs/index',
    })
  },
```

![image-20221015155028533](image-20221015155028533.png)

左上角不再是返回上一页，而是返回主页



跳转的各个方法的区别，在于关不关闭当前页面，和页面的生命周期有关，后面会讲到

如果需要单独配置某个页面的导航，可以在自己文件下的json文件中设置

`pages/logs/index.json`

```json
{
  "usingComponents": {},
  "navigationBarTitleText": "日志"
}
```

局部配置的优先级，高于全局

## 生命周期

[生命周期 | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page-life-cycle.html)

五个生命周期，如图：

- 第一次onLoad和OnShow时，逻辑层的数据还没来呢
- onLoad、onReady等执行次数，取决于路由跳转是选择的api
- 使用`wx.redirectTo`跳转路由时，会关闭当前页面，执行一次onUnload回调
- 如果使用的是`wx.navigateTo`跳转路由，页面不会销毁，切换页面时执行onHide回调

![img](page-lifecycle.2e646c86.png)



```js
/**
   * 生命周期函数--监听页面加载
   */
  onLoad(options) {
    console.log(this.msg)
    setTimeout(() => {
      this.setData({
        msg: '修改之后的数据'
      })
    },2000)
  },

  /**
   * 生命周期函数--监听页面初次渲染完成
   */
  onReady() {

  },

  /**
   * 生命周期函数--监听页面显示
   */
  onShow() {

  },

  /**
   * 生命周期函数--监听页面隐藏
   */
  onHide() {

  },

  /**
   * 生命周期函数--监听页面卸载
   */
  onUnload() {

  },

```

## 条件渲染

[条件渲染 | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/conditional.html)

```html
<view wx:if="{{length > 5}}"> 1 </view>
<view wx:elif="{{length > 2}}"> 2 </view>
<view wx:else> 3 </view>
```

## 列表渲染

[列表渲染 | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/list.html)

`wx:for`

在组件上使用 `wx:for` 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。

默认数组的当前项的下标变量名默认为 `index`，数组当前项的变量名默认为 `item`

`wx:key`

如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 [input](https://developers.weixin.qq.com/miniprogram/dev/component/input.html) 中的输入内容，[switch](https://developers.weixin.qq.com/miniprogram/dev/component/switch.html) 的选中状态），需要使用 `wx:key` 来指定列表中项目的唯一的标识符。

`wx:key` 的值以两种形式提供

1. 字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。
2. 保留关键字 `*this` 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字。



可以自定义index和item变量名

使用 `wx:for-item` 可以指定数组当前元素的变量名，

使用 `wx:for-index` 可以指定数组当前下标的变量名；

## 模板使用







# 小程序API









































